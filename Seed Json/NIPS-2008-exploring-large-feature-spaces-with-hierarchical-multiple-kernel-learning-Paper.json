{
  "pdf": "NIPS-2008-exploring-large-feature-spaces-with-hierarchical-multiple-kernel-learning-Paper",
  "title": "Exploring Large Feature Spaces with Hierarchical Multiple Kernel Learning",
  "author": "Francis R. Bach",
  "paper_id": "NIPS-2008-exploring-large-feature-spaces-with-hierarchical-multiple-kernel-learning-Paper",
  "text": "Exploring Large Feature Spaces\nw\nith Hierarchical Multiple Kernel Learning\nFrancis Bach\nI\nNRIA - Willow Project, ´Ecole Normale Sup´ erieure\n45, rue d’Ulm, 75230 Paris, France\nfrancis.bach@mines.org\nAbstract\nFor supervised and unsupervised learning, positive deﬁnite kernels allow to use\nlarge and potentially inﬁnite dimensional feature spaces with a computational cost\nthat only depends on the number of observations. This is usually done through\nthe penalization of predictor functions by Euclidean or Hilbertian norms. In this\npaper, we explore penalizing by sparsity-inducing norms such as the ℓ 1-norm or\nthe block ℓ 1-norm. We assume that the kernel decomposes into a large sum of\nindividual basis kernels which can be embedded in a directed acyclic graph; we\nshow that it is then possible to perform kernel selection through a hierarchical\nmultiple kernel learning framework, in polynomial time in the number of selected\nkernels. This framework is naturally applied to non linear variable selection; our\nextensive simulations on synthetic datasets and datasets from the UCI repository\nshow that efﬁciently exploring the large feature space through sparsity-inducing\nnorms leads to state-of-the-art predictive performance.\n1 Introduction\nIn the last two decades, kernel methods have been a proliﬁc theoretical and algorithmic machine\nlearning framework. By using appropriate regularization by Hilbertian norms, representer theorems\nenable to consider large and potentially inﬁnite-dimensional feature spaces while working within an\nimplicit feature space no larger than the number of observations. This has led to numerous works on\nkernel design adapted to speciﬁc data types and generic kernel-based algorithms for many learning\ntasks (see, e.g., [1, 2]).\nRegularization by sparsity-inducing norms, such as the ℓ 1-norm has also attracted a lot of interest in\nrecent years. While early work has focused on efﬁcient algorithms to solve the convex optimization\nproblems, recent research has looked at the model selection properties and predictive performance of\nsuch methods, in the linear case [3] or within the multiple kernel learning framework (see, e.g., [4]).\nIn this paper, we aim to bridge the gap between these two lines of research by trying to useℓ 1-norms\ninside the feature space. Indeed, feature spaces are large and we expect the estimated predictor\nfunction to require only a small number of features, which is exactly the situation where ℓ 1-norms\nhave proven advantageous. This leads to two natural questions that we try to answer in this paper: (1)\nIs it feasible to perform optimization in this very large feature space with cost which is polynomial\nin the size of the input space? (2) Does it lead to better predictive performance and feature selection?\nMore precisely, we consider a positive deﬁnite kernel that can be expressed as a large sum of positive\ndeﬁnite basis or local kernels. This exactly corresponds to the situation where a large feature space is\nthe concatenation of smaller feature spaces, and we aim to do selection among these many kernels,\nwhich may be done through multiple kernel learning. One major difﬁculty however is that the\nnumber of these smaller kernels is usually exponential in the dimension of the input space and\napplying multiple kernel learning directly in this decomposition would be intractable.\nIn order to peform selection efﬁciently, we make the extra ass umption that these small kernels can\nbe embedded in a directed acyclic graph (DAG). Following [5], we consider in Section 2 a spe-\nciﬁc combination of ℓ 2-norms that is adapted to the DAG, and will restrict the authorized sparsity\npatterns; in our speciﬁc kernel framework, we are able to use the DAG to design an optimization\nalgorithm which has polynomial complexity in the number of selected kernels (Section 3). In simu-\nlations (Section 5), we focus on directed grids, where our framework allows to perform non-linear\nvariable selection. We provide extensive experimental validation of our novel regularization frame-\nwork; in particular, we compare it to the regular ℓ 2-regularization and shows that it is always com-\npetitive and often leads to better performance, both on synthetic examples, and standard regression\nand classiﬁcation datasets from the UCI repository.\nFinally, we extend in Section 4 some of the known consistency results of the Lasso and multiple ker-\nnel learning [3, 4], and give a partial answer to the model selection capabilities of our regularization\nframework by giving necessary and sufﬁcient conditions for model consistency. In particular, we\nshow that our framework is adapted to estimating consistently only thehull of the relevant variables.\nHence, by restricting the statistical power of our method, we gain computational efﬁciency.\n2 Hierarchical multiple kernel learning (HKL)\nWe consider the problem of predicting a random variable Y ∈ Y ⊂ R from a random variable X ∈\nX , where X and Y may be quite general spaces. We assume that we are given n i.i.d. observations\n(xi, y i) ∈ X × Y , i = 1 , . . . , n . We deﬁne the empirical risk of a function f from X to R as\n1\nn\n∑n\ni= 1 ℓ(yi, f (xi)), where ℓ : Y × R ↦→ R+ is a loss function. We only assume that ℓ is convex\nwith respect to the second parameter (but not necessarily differentiable). Typical examples of loss\nfunctions are the square loss for regression, i.e., ℓ(y, ˆy) = 1\n2 (y − ˆy)2 f or y ∈ R, and the logistic loss\nℓ(y, ˆy) = log(1 + e− y ˆy) or the hinge loss ℓ(y, ˆy) = max {0, 1 − y ˆy}for binary classiﬁcation, where\ny ∈ {− 1, 1}, leading respectively to logistic regression and support vector machines [1, 2].\n2.1 Graph-structured positive deﬁnite kernels\nWe assume that we are given a positive deﬁnite kernel k : X × X → R, and that this kernel can\nbe expressed as the sum, over an index set V , of basis kernels kv, v ∈ V , i.e, for all x, x ′ ∈ X ,\nk(x, x ′) = ∑\nv∈V kv(x, x ′). For each v ∈ V , we denote by Fv and Φv the feature space and feature\nmap of kv, i.e., for all x, x ′ ∈ X , kv(x, x ′) = ⟨Φv(x), Φv(x′)⟩. Throughout the paper, we denote\nby ∥u∥ the Hilbertian norm of u and by ⟨u, v ⟩ the associated dot product, where the precise space is\nomitted and can always be inferred from the context.\nOur sum assumption corresponds to a situation where the feature map Φ(x) and feature space F\nfor k is the concatenation of the feature maps Φv(x) for each kernel kv, i.e, F = ∏\nv∈V Fv and\nΦ(x) = (Φ v(x))v∈V . Thus, looking for a certain β ∈ F and a predictor function f (x) = ⟨β, Φ(x)⟩\nis equivalent to looking jointly for β v ∈ F v, for all v ∈ V , and f (x) = ∑\nv∈V ⟨β v, Φv(x)⟩.\nAs mentioned earlier, we make the assumption that the setV can be embedded into adirected acyclic\ngraph. Directed acyclic graphs (DAGs) allow to naturally deﬁne the notions of parents, children,\ndescendants and ancestors. Given a node w ∈ V , we denote by A(w) ⊂ V the set of its ancestors,\nand by D(w) ⊂ V , the set of its descendants. We use the convention that any w is a descendant\nand an ancestor of itself, i.e., w ∈ A(w) and w ∈ D(w). Moreover, for W ⊂ V , we let denote\nsources(W ) the set of sources of the graph G restricted to W (i.e., nodes in W with no parents\nbelonging to W ). Given a subset of nodes W ⊂ V , we can deﬁne the hull of W as the union of all\nancestors of w ∈ W , i.e., hull(W ) = ⋃\nw∈W A(w). Given a set W , we deﬁne the set of extreme\npoints of W as the smallest subset T ⊂ W such that hull(T ) = hull( W ) (note that it is always well\ndeﬁned, as ⋂\nT ⊂ V, hull(T )=hull(W ) T ). See Figure 1 for examples of these notions.\nThe goal of this paper is to perform kernel selection among the kernels kv, v ∈ V . We essentially\nuse the graph to limit the search to speciﬁc subsets ofV . Namely, instead of considering all possible\nsubsets of active (relevant) vertices, we are only interested in estimating correctly the hull of these\nrelevant vertices; in Section 2.2, we design a speciﬁc sparsity-inducing norms adapted to hulls.\nIn this paper, we primarily focus on kernels that can be expressed as “products of sums”, and on the\nassociated p-dimensional directed grids, while noting that our framework is applicable to many other\nkernels. Namely, we assume that the input spaceX factorizes into p components X = X1 × · · ·× X p\nand that we are given p sequences of length q + 1 of kernels kij(xi, x ′\ni), i ∈ { 1, . . . , p }, j ∈\nFigure 1: Example of graph and associated notions. (Left) Exa mple of a 2D-grid. (Middle) Example\nof sparsity pattern ( × in light blue) and the complement of its hull ( + in light red). (Right) Dark\nblue points (× ) are extreme points of the set of all active points (blue× ); dark red points (+) are the\nsources of the set of all red points (+).\n{0, . . . , q }, such that k(x, x ′) = ∑q\nj1,...,jp=0\n∏p\ni=1 kiji (xi, x ′\ni) = ∏p\ni=1\n( ∑q\nji=0 kiji (xi, x ′\ni)\n)\n. We\nthus have a sum of(q+1)p kernels, that can be computed efﬁciently as a product ofp sums. A natural\nDAG on V = ∏p\ni=1{0, . . . , q } is deﬁned by connecting each (j1, . . . , j p) to (j1 + 1, j 2, . . . , j p),\n. . . , (j1, . . . , j p− 1, j p + 1). As shown in Section 2.2, this DAG will correspond to the constraint\nof selecting a given product of kernels only after all the subproducts are selected. Those DAGs\nare especially suited to nonlinear variable selection, in particular with the polynomial and Gaussian\nkernels. In this context, products of kernels correspond to interactions between certain variables, and\nour DAG implies that we select an interaction only after all sub-interactions were already selected.\nPolynomial kernels We consider Xi = R, kij(xi, x ′\ni) =\n( q\nj\n)\n(xix′\ni)j; the full kernel is then equal\nto k(x, x ′) = ∏p\ni=1\n∑q\nj=0\n( q\nj\n)\n(xix′\ni)j = ∏p\ni=1(1 + xix′\ni)q. Note that this is not exactly the usual\npolynomial kernel (whose feature space is the space of multivariate polynomials oftotal degree less\nthan q), since our kernel considers polynomials of maximal degree q.\nGaussian kernels We also consider Xi = R, and the Gaussian-RBF kernel e− b(x− x′)2\n. The\nfollowing decomposition is the eigendecomposition of the non centered covariance operator for a\nnormal distribution with variance 1/ 4a (see, e.g., [6]):\ne− b(x− x′)2\n= ∑∞\nk=0\n(b/A)k\n2kk! [e− b\nA (a+c)x2\nHk(\n√\n2c x )][e− b\nA (a+c) (x′)2\nHk(\n√\n2c x ′)],\nwhere c2 = a2 + 2ab, A = a + b + c, and Hk is the k-th Hermite polynomial. By appropriately\ntruncating the sum, i.e, by considering that the ﬁrst q basis kernels are obtained from the ﬁrst q\nsingle Hermite polynomials, and the (q + 1)-th kernel is summing over all other kernels, we ob-\ntain a decomposition of a uni-dimensional Gaussian kernel into q + 1 components (q of them are\none-dimensional, the last one is inﬁnite-dimensional, but can be computed by differencing). The\ndecomposition ends up being close to a polynomial kernel of inﬁnite degree, modulated by an ex-\nponential [2]. One may also use an adaptive decomposition using kernel PCA (see, e.g., [2, 1]),\nwhich is equivalent to using the eigenvectors of the empirical covariance operator associated with\nthe data (and not the population one associated with the Gaussian distribution with same variance).\nIn simulations, we tried both with no signiﬁcant differences.\nANOV A kernels When q = 1 , the directed grid is isomorphic to the power set (i.e., the set\nof subsets) with the inclusion DAG. In this setting, we can decompose the ANOV A kernel [2] as∏p\ni=1(1 + e− b(xi− x′\ni)2\n) = ∑\nJ⊂{1,...,p}\n∏\ni∈J e− b(xi− x′\ni)2\n= ∑\nJ⊂{1,...,p} e− b∥xJ − x′\nJ ∥2\n2, and our\nframework will select the relevant subsets for the Gaussian kernels.\nKernels or features? In this paper, we emphasize the kernel view, i.e., we are given a kernel (and\nthus a feature space) and we explore it usingℓ 1-norms. Alternatively, we could use thefeature view,\ni.e., we have a large structured set of features that we try to select from; however, the techniques\ndeveloped in this paper assume that (a) each feature might be inﬁnite-dimensional and (b) that we\ncan sum all the local kernels efﬁciently (see in particular Section 3.2). Following the kernel view\nthus seems slightly more natural.\n2.2 Graph-based structured regularization\nGiven β ∈ ∏\nv∈V Fv, the natural Hilbertian norm ∥β ∥ is deﬁned through ∥β ∥2 = ∑\nv∈V ∥β v∥2.\nPenalizing with this norm is efﬁcient because summing all kernelskv is assumed feasible in polyno-\nmial time and we can bring to bear the usual kernel machinery; however, it does not lead to sparse\nsolutions, where many β v will be exactly equal to zero.\nAs said earlier, we are only interested in the hull of the selec ted elements β v ∈ F v, v ∈ V ; the hull\nof a set I is characterized by the set of v, such that D(v) ⊂ I c, i.e., such that all descendants of v\nare in the complement I c: hull(I) = {v ∈ V, D(v) ⊂ I c}c. Thus, if we try to estimate hull(I), we\nneed to determine which v ∈ V are such that D(v) ⊂ I c. In our context, we are hence looking at\nselecting vertices v ∈ V for which β D(v) = (β w)w∈D(v) = 0.\nWe thus consider the following structured block ℓ 1-norm deﬁned as ∑\nv∈V dv∥β D(v)∥ =∑\nv∈V dv(∑\nw∈D(v) ∥β w∥2)1/2, where (dv)v∈V are positive weights. Penalizing by such a norm\nwill indeed impose that some of the vectors β D(v) ∈ ∏\nw∈D(v) Fw are exactly zero. We thus con-\nsider the following minimization problem1:\nminβ∈Q\nv∈V Fv\n1\nn\n∑n\ni= 1 ℓ(yi, ∑\nv∈V ⟨β v, Φv(xi)⟩) + λ\n2\n( ∑\nv∈V dv∥β D (v)∥\n) 2\n. (1)\nOur Hilbertian norm is a Hilbert space instantiation of the hierarchical norms recently introduced\nby [5] and also considered by [7] in the MKL setting. If all Hilbert spaces are ﬁnite dimensional, our\nparticular choice of norms corresponds to an “ ℓ 1-norm of ℓ 2-norms”. While with uni-dimensional\ngroups/kernels, the “ ℓ 1-norm of ℓ ∞ -norms” allows an efﬁcient path algorithm for the square loss\nand when the DAG is a tree [5], this is not possible anymore with groups of size larger than one, or\nwhen the DAG is a not a tree. In Section 3, we propose a novel algorithm to solve the associated\noptimization problem in time polynomial in the number of selected groups/kernels, for all group\nsizes, DAGs and losses. Moreover, in Section 4, we show under which conditions a solution to the\nproblem in Eq. (1) consistently estimates the hull of the sparsity pattern.\nFinally, note that in certain settings (ﬁnite dimensional Hilbert spaces and distributions with abso-\nlutely continuous densities), these norms have the effect of selecting a given kernel only after all of\nits ancestors [5]. This is another explanation why hulls end up being selected, since to include a\ngiven vertex in the models, the entire set of ancestors must also be selected.\n3 Optimization problem\nIn this section, we give optimality conditions for the problems in Eq. (1), as well as optimization\nalgorithms with polynomial time complexity in the number of selected kernels. In simulations we\nconsider total numbers of kernels larger than 1030, and thus such efﬁcient algorithms are essential\nto the success of hierarchical multiple kernel learning (HKL).\n3.1 Reformulation in terms of multiple kernel learning\nFollowing [8, 9], we can simply derive an equivalent formulation of Eq. (1). Using Cauchy-Schwarz\ninequality, we have that for all η ∈ RV such that η ⩾ 0 and ∑\nv∈V d2\nvη v ⩽ 1,\n(∑\nv∈V dv∥β D(v)∥)2 ⩽ ∑\nv∈V\n∥βD(v)∥2\nηv\n= ∑\nw∈V (∑\nv∈A (w) η − 1\nv )∥β w∥2,\nwith equality if and only if η v = d− 1\nv ∥β D(v)∥(∑\nv∈V dv∥β D(v)∥)− 1. We associate to the vector\nη ∈ RV , the vector ζ ∈ RV such that ∀w ∈ V , ζ − 1\nw = ∑\nv∈A(w) η − 1\nv . We use the natural convention\nthat if η v is equal to zero, then ζ w is equal to zero for all descendants w of v. We let denote H the\nset of allowed η and Z the set of all associated ζ . The set H and Z are in bijection, and we can\ninterchangeably use η ∈ H or the corresponding ζ (η ) ∈ Z. Note that Z is in general not convex 2\n(unless the DAG is a tree, see [10]), and if ζ ∈ Z, then ζ w ⩽ ζ v for all w ∈ D(v), i.e., weights of\ndescendant kernels are smaller, which is consistent with the known fact that kernels should always\nbe selected after all their ancestors.\nThe problem in Eq. (1) is thus equivalent to\nmin\nη∈H\nmin\nβ∈Q\nv∈V Fv\n1\nn\n∑n\ni= 1 ℓ(yi, ∑\nv∈V ⟨β v, Φv(xi)⟩) + λ\n2\n∑\nw∈V ζ w(η )− 1∥β w∥2. ( 2)\nUsing the change of variable ˜β v = β vζ − 1/2\nv and ˜Φ(x) = ( ζ 1/2\nv Φv(x))v∈V , this implies that given\nthe optimal η (and associated ζ ), β corresponds to the solution of the regular supervised learning\nproblem with kernel matrix K = ∑\nw∈V ζ wKw, where Kw is n × n the kernel matrix associated\n1W e consider the square of the norm, which does not change the regularization properties, but allow simple\nlinks with multiple kernel learning.\n2Although Z is not convex, we can still maximize positive linear combinations over Z, which is the only\nneeded operation (see [10] for details).\nwith kernel kw. Moreover, the solution is then β w = ζ w\n∑n\ni=1 α iΦw(xi), where α ∈ Rn are the\ndual parameters associated with the single kernel learning problem.\nThus, the solution is entirely determined by α ∈ Rn and η ∈ RV (and its corresponding ζ ∈ RV ).\nMore precisely, we have (see proof in [10]):\nProposition 1 The pair (α, η ) is optimal for Eq. (1), with ∀w, β w = ζ w\n∑n\ni=1 α iΦw(xi), if and\nonly if (a) given η , α is optimal for the single kernel learning problem with kernel matrix K =∑\nw∈V ζ w(η )Kw, and (b) given α , η ∈ H maximizes ∑\nw∈V (∑\nv∈A(w) η − 1\nv )− 1α ⊤ Kwα .\nMoreover, the total duality gap can be upperbounded as the sum of the two separate duality gaps for\nthe two optimization problems, which will be useful in Section 3.2 (see [10] for more details). Note\nthat in the case of “ﬂat” regular multiple kernel learning, where the DAG has no edges, we obtain\nback usual optimality conditions [8, 9].\nFollowing a common practice for convex sparsity problems [11], we will try to solve a small problem\nwhere we assume we know the set of v such that ∥β D(v)∥ is equal to zero (Section 3.3). We then\n“simply” need to check that variables in that set may indeed be left out of the solution. In the next\nsection, we show that this can be done in polynomial time although the number of kernels to consider\nleaving out is exponential (Section 3.2).\n3.2 Conditions for global optimality of reduced problem\nWe let denote J the complement of the set of norms which are set to zero. We thus consider the\noptimal solution β of the reduced problem (on J), namely,\nminβJ ∈Q\nv∈J Fv\n1\nn\n∑n\ni= 1 ℓ(yi, ∑\nv∈J ⟨β v, Φv(xi)⟩) + λ\n2\n( ∑\nv∈V dv∥β D (v)∩J ∥\n) 2\n, (3)\nwith optimal primal variables β J, dual variables α and optimal pair (η J , ζ J ). We now consider\nnecessary conditions and sufﬁcient conditions for this solution (augmented with zeros for non active\nvariables, i.e., variables in J c) to be optimal with respect to the full problem in Eq. (1). We denote\nby δ = ∑\nv∈J dv∥β D(v)∩J ∥ the optimal value of the norm for the reduced problem.\nProposition 2 (NJ) If the reduced solution is optimal for the full problem in Eq. (1) and all kernels\nin the extreme points of J are active, then we have maxt∈sources(J c) α ⊤ Ktα/d 2\nt ⩽ δ 2 .\nProposition 3 (SJ,ε) If maxt∈sources(J c)\n∑\nw∈D(t) α ⊤ Kwα/ (∑\nv∈A(w)∩D(t) dv)2 ⩽ δ 2 + ε/λ ,\nthen the total duality gap is less than ε .\nThe proof is fairly technical and can be found in [10]; this result constitutes the main technical\ncontribution of the paper: it essentially allows to solve a very large optimization problem over\nexponentially many dimensions in polynomial time.\nThe necessary condition (NJ ) does not cause any computational problems. However, the sufﬁcient\ncondition (SJ,ε) requires to sum over all descendants of the active kernels, which is impossible in\npractice (as shown in Section 5, we consider V of cardinal often greater than 1030). Here, we need\nto bring to bear the speciﬁc structure of the kernel k. In the context of directed grids we consider\nin this paper, if dv can also be decomposed as a product, then ∑\nv∈A(w)∩D(t) dv is also factorized,\nand we can compute the sum over all v ∈ D(t) in linear time in p. Moreover we can cache the sums∑\nw∈D(t) Kw/ (∑\nv∈A(w)∩D(t) dv)2 in order to save running time.\n3.3 Dual optimization for reduced or small problems\nWhen kernels kv, v ∈ V have low-dimensional feature spaces, we may use a primal rep-\nresentation and solve the problem in Eq. (1) using generic optimization toolboxes adapted to\nconic constraints (see, e.g., [12]). However, in order to reuse existing optimized supervised\nlearning code and use high-dimensional kernels, it is preferable to use a dual optimization.\nNamely, we use the same technique as [8]: we consider for ζ ∈ Z, the function B(ζ ) =\nminβ∈Q\nv∈V Fv\n1\nn\n∑n\ni= 1 ℓ(yi, ∑\nv∈V ⟨β v, Φv(xi)⟩)+ λ\n2\n∑\nw∈V ζ − 1\nw ∥β w∥2, which is the optimal value\nof the single kernel learning problem with kernel matrix∑\nw∈V ζ wKw. Solving Eq. (2) is equivalent\nto minimizing B(ζ (η )) with respect to η ∈ H.\nIf a ridge (i.e., positive diagonal) is added to the kernel matrices, the functionB is differentiable [8].\nMoreover, the function η ↦→ ζ (η ) is differentiable on (R∗\n+)V . Thus, the function η ↦→ B[ζ ((1 −\nε )η + ε\n|V |d− 2) ] , where d− 2 is the vector with elements d− 2\nv , is differentiable if ε > 0. We can then\nuse the same projected gradient descent strategy as [8] to minimize it. The overall complexity of\nthe algorithm is then proportional to O(|V |n2)—to form the kernel matrices—plus the complexity\nof solving a single kernel learning problem—typically between O(n2) and O(n3). Note that this\nalgorithm is only used for small reduced subproblems for which V has small cardinality.\n3.4 Kernel search algorithm\nWe are now ready to present the detailed algorithm which extends the feature search algorithm\nof [11]. Note that the kernel matrices are never all needed explicitly, i.e., we only need them (a)\nexplicitly to solve the small problems (but we need only a few of those) and (b) implicitly to compute\nthe sufﬁcient condition (SJ,ε), which requires to sum over all kernels, as shown in Section 3.2.\n• Input: kernel matrices Kv ∈ Rn× n, v ∈ V , maximal gap ε , maximal # of kernels Q\n• Algorithm\n1. Initialization: set J = sources(V ),\ncompute (α, η ) solutions of Eq. (3), obtained using Section 3.3\n2. while (NJ ) and (SJ,ε) are not satisﬁed and #(V ) ⩽ Q\n– If (NJ ) is not satisﬁed, add violating variables in sources(J c) to J\nelse, add violating variables in sources(J c) of (SJ,ε) to J\n– Recompute (α, η ) optimal solutions of Eq. (3)\n• Output: J, α , η\nThe previous algorithm will stop either when the duality gap is less than ε or when the maximal\nnumber of kernels Q has been reached. In practice, when the weights dv increase with the depth of\nv in the DAG (which we use in simulations), the small duality gap generally occurs before we reach\na problem larger than Q. Note that some of the iterations only increase the size of the active sets to\ncheck the sufﬁcient condition for optimality; forgetting those does not change the solution, only the\nfact that we may actually know that we have an ε -optimal solution.\nIn order to obtain a polynomial complexity, the maximal out-degree of the DAG (i.e., the maximal\nnumber of children of any given node) should be polynomial as well. Indeed, for the directed p-\ngrid (with maximum out-degree equal to p), the total running time complexity is a function of the\nnumber of observations n, and the number R of selected kernels; with proper caching, we obtain the\nfollowing complexity, assumingO(n3) for the single kernel learning problem, which is conservative:\nO(n3R + n2Rp2 + n2R2p), which decomposes into solving O(R) single kernel learning problems,\ncaching O(Rp) kernels, and computing O(R2p) quadratic forms for the sufﬁcient conditions.\n4 Consistency conditions\nAs said earlier, the sparsity pattern of the solution of Eq. (1) will be equal to its hull, and thus we\ncan only hope to obtain consistency of the hull of the pattern, which we consider in this section. For\nsimplicity, we consider the case of ﬁnite dimensional Hilbert spaces (i.e.,Fv = Rfv ) and the square\nloss. We also hold ﬁxed the vertex set ofV , i.e., we assume that the total number of features is ﬁxed,\nand we let n tend to inﬁnity and λ = λ n decrease with n.\nFollowing [4], we make the following assumptions on the underlying joint distribution of (X, Y ):\n(a) the joint covariance matrix Σ of (Φ(xv))v∈V (deﬁned with appropriate blocks of size fv × fw)\nis invertible, (b) E(Y |X) = ∑\nw∈W ⟨βw, Φw(x)⟩ with W ⊂ V and var(Y |X) = σ2 > 0 almost\nsurely. With these simple assumptions, we obtain (see proof in [10]):\nProposition 4 (Sufﬁcient condition) If max\nt∈sources(W c)\n∑\nw∈D(t)\n∥ΣwW Σ− 1\nW W Diag(dv∥βD(v)∥− 1)v∈W βW ∥2\n(P\nv∈A (w)∩D(t) dv)2\n< 1, then β and the hull of W are consistently estimated when λ nn1/2 → ∞ and λ n → 0.\nProposition 5 (Necessary condition) If the β and the hull of W are consistently estimated for\nsome sequence λ n, then maxt∈sources(W c) ∥ΣwW Σ− 1\nW W Diag(dv/ ∥βD(v)∥)v∈W βW ∥2/d 2\nt ⩽ 1.\nNote that the last two propositions are not consequences of the similar results for ﬂat MKL [4],\nbecause the groups that we consider are overlapping. Moreover, the last propositions show that we\nindeed can estimate the correct hull of the sparsity pattern if the sufﬁcient condition is satisﬁed. In\nparticular, if we can make the groups such that the between-group correlation is as small as possible,\n2 3 4 5 6 70\n0.5\n1\nlog2(p)\ntest set error\n \n \nHKL\ngreedy\nL2\n2 3 4 5 6 70\n0.5\n1\nlog2(p)\ntest set error\n \n \nHKL\ngreedy\nL2\nFigure 2: Comparison on synthetic examples: mean squared err or over 40 replications (with halved\nstandard deviations). Left: non rotated data, right: rotated data. See text for details.\ndataset n p k #(V ) L2 greedy lasso- α M KL HKL\nabalone 4177 10 pol4 ≈1 07 44.2±1 .3 43.9 ±1.4 47.9 ±0.7 44.5 ±1.1 43.3±1.0\nabalone 4177 10 rbf ≈1 010 43.0±0 .9 45.0±1.7 49.0 ±1.7 43.7 ±1.0 43.0 ±1.1\nbank-32fh 8192 32 pol4 ≈1 022 40.1±0 .7 39.2 ±0.8 41.3 ±0.7 38.7±0.7 38.9±0.7\nbank-32fh 8192 32 rbf ≈1 031 39.0±0 .7 39.7 ±0.7 66.1 ±6.9 38.4 ±0.7 38.4±0.7\nbank-32fm 8192 32 pol4 ≈1 022 6.0±0 .1 5.0±0.2 7.0±0.2 6.1 ±0.3 5.1 ±0.1\nbank-32fm 8192 32 rbf ≈1 031 5.7±0 .2 5.8 ±0.4 36.3 ±4.1 5.9 ±0.2 4.6±0.2\nbank-32nh 8192 32 pol4 ≈1 022 44.3±1 .2 46.3 ±1.4 45.8 ±0.8 46.0 ±1.2 43.6±1.1\nbank-32nh 8192 32 rbf ≈1 031 44.3±1 .2 49.4 ±1.6 93.0 ±2.8 46.1 ±1.1 43.5±1.0\nbank-32nm 8192 32 pol4 ≈1 022 17.2±0 .6 18.2 ±0.8 19.5 ±0.4 21.0 ±0.7 16.8±0.6\nbank-32nm 8192 32 rbf ≈1 031 16.9±0 .6 21.0 ±0.6 62.3 ±2.5 20.9 ±0.7 16.4±0.6\nboston 506 13 pol4 ≈1 09 17.1±3 .6 24.7±10.8 29.3 ±2.3 22.2 ±2.2 18.1 ±3.8\nboston 506 13 rbf ≈1 012 16.4±4 .0 32.4±8.2 29.4 ±1.6 20.7 ±2.1 17.1 ±4.7\npumadyn-32fh 8192 32 pol4 ≈1 022 57.3±0 .7 56.4 ±0.8 57.5 ±0.4 56.4±0.7 56.4±0.8\npumadyn-32fh 8192 32 rbf ≈1 031 57.7±0 .6 72.2 ±22.5 89.3 ±2.0 56.5 ±0.8 55.7±0.7\npumadyn-32fm 8192 32 pol4 ≈1 022 6.9±0 .1 6.4 ±1.6 7.5 ±0.2 7.0 ±0.1 3.1±0.0\npumadyn-32fm 8192 32 rbf ≈1 031 5.0±0 .1 46.2 ±51.6 44.7 ±5.7 7.1 ±0.1 3.4±0.0\npumadyn-32nh 8192 32 pol4 ≈1 022 84.2±1 .3 73.3 ±25.4 84.8 ±0.5 83.6 ±1.3 36.7±0.4\npumadyn-32nh 8192 32 rbf ≈1 031 56.5±1 .1 81.3 ±25.0 98.1 ±0.7 83.7 ±1.3 35.5±0.5\npumadyn-32nm 8192 32 pol4 ≈1 022 60.1±1 .9 69.9 ±32.8 78.5 ±1.1 77.5 ±0.9 5.5±0.1\npumadyn-32nm 8192 32 rbf ≈1 031 15.7±0 .4 67.3 ±42.4 95.9 ±1.9 77.6 ±0.9 7.2±0.1\nTable 1: Mean squared errors (multiplied by 100) on UCI regres sion datasets, normalized so that the\ntotal variance to explain is 100. See text for details.\nwe can ensure correct hull selection. Finally, it is worth noting that if the ratios dw/ maxv∈A(w) dv\ntend to inﬁnity slowly with n, then we always consistently estimate the depth of the hull, i.e., the\noptimal interaction complexity. We are currently investigating extensions to the non parametric\ncase [4], in terms of pattern selection and universal consistency.\n5 Simulations\nSynthetic examples We generated regression data as follows: n = 1024 samples of p ∈ [22, 27]\nvariables were generated from a random covariance matrix, and the label y ∈ R was sampled as a\nrandom sparse fourth order polynomial of the input variables (with constant number of monomials).\nWe then compare the performance of our hierarchical multiple kernel learning method (HKL) with\nthe polynomial kernel decomposition presented in Section 2 to other methods that use the same\nkernel and/or decomposition: (a) the greedy strategy of selecting basis kernels one after the other, a\nprocedure similar to [13], and (b) the regular polynomial kernel regularization with the full kernel\n(i.e., the sum of all basis kernels). In Figure 2, we compare the two approaches on 40 replications in\nthe following two situations: original data (left) and rotated data (right), i.e., after the input variables\nwere transformed by a random rotation (in this situation, the generating polynomial is not sparse\nanymore). We can see that in situations where the underlying predictor function is sparse (left),\nHKL outperforms the two other methods when the total number of variables p increases, while in\nthe other situation where the best predictor is not sparse (right), it performs only slightly better: i.e.,\nin non sparse problems, ℓ 1-norms do not really help, but do help a lot when sparsity is expected.\nUCI datasets For regression datasets, we compare HKL with polynomial (degree 4) and Gaussian-\nRBF kernels (each dimension decomposed into 9 kernels) to the following approaches with the same\ndataset n p k #(V ) L2 greedy HKL\nmushrooms 1024 117 pol4 ≈1 082 0.4±0 .4 0.1±0.1 0.1±0.2\nmushrooms 1024 117 rbf ≈1 0112 0.1±0 .2 0.1±0.2 0.1 ±0.2\nringnorm 1024 20 pol4 ≈1 014 3.8±1 .1 5.9 ±1.3 2.0±0.3\nringnorm 1024 20 rbf ≈1 019 1.2±0 .4 2.4±0.5 1.6 ±0.4\nspambase 1024 57 pol4 ≈1 040 8.3±1 .0 9.7 ±1.8 8.1±0.7\nspambase 1024 57 rbf ≈1 054 9.4±1 .3 10.6 ±1.7 8.4±1.0\ntwonorm 1024 20 pol4 ≈1 014 2.9±0 .5 4.7±0.5 3.2 ±0.6\ntwonorm 1024 20 rbf ≈1 019 2.8±0 .6 5.1±0.7 3.2 ±0.6\nmagic04 1024 10 pol4 ≈1 07 15.9±1 .0 16.0 ±1.6 15.6±0.8\nmagic04 1024 10 rbf ≈1 010 15.7±0 .9 17.7 ±1.3 15.6±0.9\nTable 2: Error rates (multiplied by 100) on UCI binary classiﬁ cation datasets. See text for details.\nkernel: regular Hilbertian regularization (L2), same greedy approach as earlier (greedy), regulariza-\ntion by the ℓ 1-norm directly on the vector α , a strategy which is sometimes used in the context of\nsparse kernel learning [14] but does not use the Hilbertian structure of the kernel (lasso-α ), multiple\nkernel learning with the p kernels obtained by summing all kernels associated with a single variable\n(MKL). For all methods, the kernels were held ﬁxed, while in Table 1, we report the performance\nfor the best regularization parameters obtained by 10 random half splits.\nWe can see from Table 1, that HKL outperforms other methods, in particular for the datasets bank-\n32nm, bank-32nh, pumadyn-32nm, pumadyn-32nh, which are datasets dedicated to non linear re-\ngression. Note also, that we efﬁciently explore DAGs with very large numbers of vertices #(V ).\nFor binary classiﬁcation datasets, we compare HKL (with the logistic loss) to two other methods (L2,\ngreedy) in Table 2. For some datasets (e.g., spambase), HKL works better, but for some others, in\nparticular when the generating problem is known to be non sparse (ringnorm, twonorm), it performs\nslightly worse than other approaches.\n6 Conclusion\nWe have shown how to perform hierarchical multiple kernel learning (HKL) in polynomial time in\nthe number of selected kernels. This framework may be applied to many positive deﬁnite kernels\nand we have focused on polynomial and Gaussian kernels used for nonlinear variable selection.\nIn particular, this paper shows that trying to use ℓ 1-type penalties may be advantageous inside the\nfeature space. We are currently investigating applications to string and graph kernels [2].\nReferences\n[1] B. Sch¨ olkopf and A. J. Smola.Learning with Kernels. MIT Press, 2002.\n[2] J. Shawe-Taylor and N. Cristianini. Kernel Methods for Pattern Analysis. Camb. U. P., 2004.\n[3] P. Zhao and B. Yu. On model selection consistency of Lasso. JMLR, 7:2541–2563, 2006.\n[4] F. Bach. Consistency of the group Lasso and multiple kernel learning. JMLR, 9:1179–1225, 2008.\n[5] P. Zhao, G. Rocha, and B. Yu. Grouped and hierarchical model selection through composite absolute\npenalties. Ann. Stat., To appear, 2008.\n[6] C. K. I. Williams and M. Seeger. The effect of the input density distribution on kernel-based classiﬁers.\nIn Proc. ICML, 2000.\n[7] M. Szafranski, Y . Grandvalet, and A. Rakotomamonjy. Composite kernel learning. In Proc. ICML, 2008.\n[8] A. Rakotomamonjy, F. Bach, S. Canu, and Y . Grandvalet. Simplemkl. JMLR, 9:2491–2521, 2008.\n[9] M. Pontil and C.A. Micchelli. Learning the kernel function via regularization. JMLR, 6:1099–1125, 2005.\n[10] F. Bach. Exploring large feature spaces with hierarchical MKL. Technical Report 00319660, HAL, 2008.\n[11] H. Lee, A. Battle, R. Raina, and A. Ng. Efﬁcient sparse coding algorithms. In NIPS, 2007.\n[12] S. Boyd and L. Vandenberghe. Convex Optimization. Cambridge Univ. Press, 2003.\n[13] K. Bennett, M. Momma, and J. Embrechts. Mark: A boosting algorithm for heterogeneous kernel models.\nIn Proc. SIGKDD, 2002.\n[14] V . Roth. The generalized Lasso. IEEE Trans. on Neural Networks, 15(1), 2004.",
  "values": {
    "Transparent (to users)": "Yes",
    "Interpretable (to users)": "Yes",
    "Respect for Law and public interest": "Yes",
    "Respect for Persons": "Yes",
    "Autonomy (power to decide)": "Yes",
    "Privacy": "Yes",
    "Non-maleficence": "Yes",
    "Beneficence": "Yes",
    "Not socially biased": "Yes",
    "Justice": "Yes",
    "User influence": "Yes",
    "Fairness": "Yes",
    "Deferral to humans": "Yes",
    "Explicability": "Yes",
    "Collective influence": "Yes",
    "Critiqability": "Yes"
  }
}