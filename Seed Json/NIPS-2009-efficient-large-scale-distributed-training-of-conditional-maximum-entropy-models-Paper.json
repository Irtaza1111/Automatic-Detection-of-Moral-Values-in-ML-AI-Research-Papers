{
  "pdf": "NIPS-2009-efficient-large-scale-distributed-training-of-conditional-maximum-entropy-models-Paper",
  "title": "Efficient Large-Scale Distributed Training of Conditional Maximum Entropy Models",
  "author": "Ryan Mcdonald, Mehryar Mohri, Nathan Silberman, Dan Walker, Gideon S. Mann",
  "paper_id": "NIPS-2009-efficient-large-scale-distributed-training-of-conditional-maximum-entropy-models-Paper",
  "text": "Efﬁcient Large-Scale Distributed Training of\nConditional Maximum Entropy Models\nGideon Mann\nGoogle\ngmann@google.com\nRyan McDonald\nGoogle\nryanmcd@google.com\nMehryar Mohri\nCourant Institute and Google\nmohri@cims.nyu.edu\nNathan Silberman\nGoogle\nnsilberman@google.com\nDaniel D. Walker∗\nNLP Lab, Brigham Y oung University\ndanl4@cs.byu.edu\nAbstract\nTraining conditional maximum entropy models on massive data sets requires sig-\nniﬁcant computational resources. We examine three common distributed training\nmethods for conditional maxent: a distributed gradient computation method, a\nmajority vote method, and a mixture weight method. We analyze and compare the\nCPU and network time complexity of each of these methods and present a theoret-\nical analysis of conditional maxent models, including a study of the convergence\nof the mixture weight method, the most resource-efﬁcient technique. We also re-\nport the results of large-scale experiments comparing these three methods which\ndemonstrate the beneﬁts of the mixture weight method: this method consumes\nless resources, while achieving a performance comparable to that of standard ap-\nproaches.\n1 Introduction\nConditional maximum entropy models [1, 3], conditional maxent models for short, also known as\nmultinomial logistic regression models, are widely used in applications, most prominently for multi-\nclass classiﬁcation problems with a large number of classes in natural language processing [1, 3] and\ncomputer vision [12] over the last decade or more.\nThese models are based on the maximum entropy principle of Jaynes [11], which consists of se-\nlecting among the models approximately consistent with the constraints, the one with the greatest\nentropy. They beneﬁt from a theoretical foundation similar to that of standard maxent probabilistic\nmodels used for density estimation [8]. In particular, a duality theorem for conditional maxent model\nshows that these models belong to the exponential family. As shown by Lebanon and Lafferty [13],\nin the case of two classes, these models are also closely related to AdaBoost, which can be viewed as\nsolving precisely the same optimization problem with the same constraints, modulo a normalization\nconstraint needed in the conditional maxent case to derive probability distributions.\nWhile the theoretical foundation of conditional maxent models makes them attractive, the computa-\ntional cost of their optimization problem is often prohibitive for data sets of several million points.\nA number of algorithms have been described for batch training of conditional maxent models using\na single processor. These include generalized iterative scaling [7], improved iterative scaling [8],\ngradient descent, conjugate gradient methods, and second-order methods [15, 18].\nThis paper examines distributed methods for training conditional maxent models that can scale to\nvery large samples of up to 1B instances. Both batch algorithms and on-line training algorithms such\n∗This work was conducted while at Google Research, New Y ork.\n1\nas that of [5] or stochastic gradient descent [21] can beneﬁt from parallelization, but we concentrate\nhere on batch distributed methods.\nWe examine three common distributed training methods: a distributed gradient computation method\n[4], a majority vote method, and a mixture weight method. We analyze and compare the CPU and\nnetwork time complexity of each of these methods (Section 2) and present a theoretical analysis of\nconditional maxent models (Section 3), including a study of the convergence of the mixture weight\nmethod, the most resource-efﬁcient technique. We also report the results of large-scale experiments\ncomparing these three methods which demonstrate the beneﬁts of the mixture weight method (Sec-\ntion 4): this method consumes less resources, while achieving a performance comparable to that of\nstandard approaches such as the distributed gradient computation method. 1\n2 Distributed Training of Conditional Maxent Models\nIn this section, we ﬁrst brieﬂy describe the optimization problem for conditional maximum entropy\nmodels, then discuss three common methods for distributed training of these models and compare\ntheir CPU and network time complexity.\n2.1 Conditional Maxent Optimization problem\nLet X be the input space, Y the output space, and Φ: X ×Y→ H a (feature) mapping to a Hilbert\nspace H, which in many practical settings coincides with RN , N = dim(H) < ∞. We denote by\n∥ ·∥ the norm induced by the inner product associated to H.\nLet S = ((x1,y 1),..., (xm,y m)) be a training sample of m pairs in X ×Y. A conditional maximum\nentropy model is a conditional probability of the form pw[y|x]= 1\nZ(x) exp(w · Φ(x, y)) with Z(x)=∑\ny∈Y exp(w·Φ(x, y)), where the weight or parameter vector w ∈ H is the solution of the following\noptimization problem:\nw = argmin\nw∈H\nFS (w) = argmin\nw∈H\nλ∥w∥2 − 1\nm\nm∑\ni=1\nlog pw[yi|xi]. (1)\nHere, λ ≥ 0 is a regularization parameter typically selected via cross-validation. The optimization\nproblem just described corresponds to an L2 regularization. Many other types of regularization have\nbeen considered for the same problem in the literature, in particular L1 regularization or regulariza-\ntions based on other norms. This paper will focus on conditional maximum entropy models with L2\nregularization.\nThese models have been extensively used and studied in natural language processing [1, 3] and\nother areas where they are typically used for classiﬁcation. Given the weight vector w, the output y\npredicted by the model for an input x is:\ny = argmax\ny∈Y\npw[y|x] = argmax\ny∈Y\nw · Φ(x, y). (2)\nSince the function FS is convex and differentiable, gradient-based methods can be used to ﬁnd a\nglobal minimizer w of FS . Standard training methods such as iterative scaling, gradient descent,\nconjugate gradient, and limited-memory quasi-Newton all have the general form of Figure 1, where\nthe update function Γ: H → H for the gradient ∇FS (w) depends on the optimization method\nselected. T is the number of iterations needed for the algorithm to converge to a global minimum.\nIn practice, convergence occurs when FS (w) differs by less than a constant ϵ in successive iterations\nof the loop.\n2.2 Distributed Gradient Computation Method\nSince the points are sampled i.i.d., the gradient computation in step 3 of Figure 1 can be distributed\nacross p machines. Consider a sample S =( S1, . . . , Sp) of pm points formed by p subsamples of\n1A batch parallel estimation technique for maxent models based on their connection with AdaBoost is also\ndescribed by [5]. This algorithm is quite different from the distributed gradient computation method, but, as for\nthat method, it requires a substantial amount of network resources, since updates need to be transferred to the\nmaster at every iteration.\n2\n1 w ← 0\n2 for t ← 1 to T do\n3 ∇FS (w) ← GRADIENT (FS (w))\n4 w ← w +Γ( ∇FS (w))\n5 return w\nFigure 1: Standard Training\n1 w ← 0\n2 for t ← 1 to T do\n3 ∇FS (w) ← DIST GRADIENT (FSk (w) ∥ p machines)\n4 w ← w +Γ( ∇FS (w))\n5U PDATE (w ∥ p machines)\n6 return w\nFigure 2: Distributed Gradient Training\nm points drawn i.i.d., S1,...,S p. At each iteration, the gradients ∇FSk (w) are computed by these\np machines in parallel. These separate gradients are then summed up to compute the exact global\ngradient on a single machine, which also performs the optimization step and updates the weight\nvector received by all other machines (Figure 2). Chu et al. [4] describe a map-reduce formulation\nfor this computation, where each training epoch consists of one map (compute each ∇FSk (w))\nand one reduce (update w). However, the update method they present is that of Newton-Raphson,\nwhich requires the computation of the Hessian. We do not consider such strategies, since Hessian\ncomputations are often infeasible for large data sets.\n2.3 Majority V ote Method\nThe ensemble methods described in the next two paragraphs are based on mixture weights µ ∈ Rp.\nLet ∆p = {µ ∈ Rp : µ ≥ 0 ∧∑p\nk=1 µk =1 } denote the simplex of Rp and let µ ∈ ∆p. In the absence\nof any prior knowledge, µ is chosen to be the uniform mixture µ0 = (1/p, . . . ,1/p) as in all of our\nexperiments.\nInstead of computing the gradient of the global function in parallel, a (weighted) majority vote\nmethod can be used. Each machine receives one subsample Sk, k ∈ [1,p ], and computes wk =\nargminw∈H FSk (w) by applying the standard training of Figure 1 to Sk. The output y predicted by\nthe majority vote method for an input x is\ny = argmax\ny∈Y\np∑\nk=1\nµk I(argmax\ny′∈Y\npwk [y′|x]= y), (3)\nwhere I is an indicator function of the predicate it takes as argument. Alternatively, the con-\nditional class probabilities could be used to take into account the uncertainty of each classiﬁer:\ny = argmax\ny\n∑p\nk=1 µk pwk [y|x].\n2.4 Mixture Weight Method\nThe cost of storing p weight vectors can make the majority vote method unappealing. Instead, a\nsingle mixture weight wµ can be deﬁned form the weight vectors wk, k ∈ [1,p ]:\nwµ =\np∑\nk=1\nµkwk. (4)\nThe mixture weight wµ can be used directly for classiﬁcation.\n2.5 Comparison of CPU and Network Times\nThis section compares the CPU and network time complexity of the three training methods just\ndescribed. Table 1 summarizes these results. Here, we denote by N the dimension of H. User CPU\nrepresents the CPU time experienced by the user, cumulative CPU the total amount of CPU time for\nthe machines participating in the computation, and latency the experienced runtime effects due to\nnetwork activity. The cumulative network usage is the amount of data transferred across the network\nduring a distributed computation.\nFor a training sample of pm points, both the user and cumulative CPU times are in Ocpu(T pmN)\nwhen training on a single machine (Figure 1) since at each of t he T iterations, the gradient compu-\ntation must iterate over all pm training points and update all the components of w.\n3\nTraining\n Training\n Training\n Prediction\nUser CPU + Latency\n Cum. CPU\n Cum. Network\n User CPU\nSingle Machine\n Ocpu(pmN T)\n Ocpu(pmN T)\n N/A\n Ocpu(N )\nDistributed Gradient\n Ocpu(mN T)+ Olat(NT )\n Ocpu(pmN T)\n Onet (pN T)\n Ocpu(N )\nMajority V ote\n Ocpu(mN Tmax)+ Olat(N )\n Pp\nk=1 Ocpu(mN Tk )\n Onet (pN )\n Ocpu(pN )\nMixture Weight\n Ocpu(mN Tmax)+ Olat(N )\n Pp\nk=1 Ocpu(mN Tk )\n Onet (pN )\n Ocpu(N )\nTable 1: Comparison of CPU and network times.\nFor the distributed gradient method (Section 2.2), the worst-case user CPU of the gradient and\nparameter update computations (lines 3-4 of Figure 2) is Ocpu(mN + pN + N ) since each parallel\ngradient calculation takes mN to compute the gradient for m instances, p gradients of size N need\nto be summed, and the parameters updated. We assume here that the time to compute Γ is negligible.\nIf we assume that p ≪ m, then, the user CPU is in Ocpu(mN T). Note that the number of iterations\nit takes to converge, T , is the same as when training on a single machine since the computations are\nidentical.\nIn terms of network usage, a distributed gradient strategy will incur a cost of Onet(pN T) and a\nlatency proportional to Olat(NT ), since at each iteration w must be transmitted to each of the\np machines (in parallel) and each ∇FSk (w) returned back to the master. Network time can be\nimproved through better data partitioning of S when Φ(x, y) is sparse. The exact runtime cost of\nlatency is complicated as it depends on factors such as the physical distance between the master and\neach machine, connectivity, the switch fabric in the network, and CPU costs required to manage\nmessages. For parallelization on massively multi-core machines [4], communication latency might\nbe negligible. However, in large data centers running commodity machines, a more common case,\nnetwork latency cost can be signiﬁcant.\nThe training times are identical for the majority vote and mixture weight techniques. Let Tk be the\nnumber of iterations for training the kth mixture component wk and let Tmax = max{T1,...,T p}.\nThen, the user CPU usage of training is in Ocpu(mN Tmax), similar to that of the distributed gradient\nmethod. However, in practice, Tmax is typically less than T since convergence is often faster with\nsmaller data sets. A crucial advantage of these methods over the distributed gradient method is that\ntheir network usage is signiﬁcantly less than that of the distributed gradient computation. While\nparameters and gradients are exchanged at each iteration for this method, majority vote and mixture\nweight techniques only require the ﬁnal weight vectors to be transferred at the conclusion of training.\nThus, the overall network usage is Onet(pN ) with a latency in Olat(NT ). The main difference\nbetween the majority vote and mixture weight methods is the user CPU (and memory usage) for\nprediction which is in Ocpu(pN ) versus Ocpu(N ) for the mixture weight method. Prediction could\nbe distributed over p machines for the majority vote method, but that would incur additional machine\nand network bandwidth costs.\n3 Theoretical Analysis\nThis section presents a theoretical analysis of conditional maxent models, including a study of the\nconvergence of the mixture weight method, the most resource-efﬁcient technique, as suggested in\nthe previous section.\nThe results we obtain are quite general and include the proof of several fundamental properties of\nthe weight vector w obtained when training a conditional maxent model. We ﬁrst prove the stability\nof w in response to a change in one of the training points. We then give a convergence bound for\nw as a function of the sample size in terms of the norm of the feature space and also show a similar\nresult for the mixture weight wµ. These results are used to compare the weight vector wpm obtained\nby training on a sample of size pm with the mixture weight vector wµ.\nConsider two training samples of size m, S =( z1,...,z m−1,z m) and S′ =( z1,...,z m−1,z ′\nm),\nwith elements in X ×Y , that differ by a single training point, which we arbitrarily set as the last one\nof each sample: zm =( xm,y m) and z′\nm =( x′\nm,y ′\nm). Let w denote the parameter vector returned\nby conditional maximum entropy when trained on sample S, w′ the vector returned when trained\non S′, and let ∆w denote w′ − w. We shall assume that the feature vectors are bounded, that is\nthere exists R> 0 such that for all (x, y) in X ×Y , ∥Φ(x, y)∥≤ R. Our bounds are derived using\n4\ntechniques similar to those used by Bousquet and Elisseeff [2], or other authors, e.g., [6], in the\nanalysis of stability. In what follows, for any w ∈ H and z =( x, y) ∈ X ×Y , we denote by Lz (w)\nthe negative log-likelihood - log pw[y|x].\nTheorem 1. Let S′ and S be two arbitrary samples of size m differing only by one point. Then, the\nfollowing stability bound holds for the weight vector returned by a conditional maxent model:\n∥∆w∥≤ 2R\nλm . (5)\nProof. We denote by BF the Bregman divergence associated to a convex and differentiable function\nF deﬁned for all u, u′ by: BF (u′∥u)= F (u′)−F (u)−∇F (u)·(u′−u). Let GS denote the function\nu ↦→ 1\nm\n∑m\ni=1 Lzi (u) and W the function u ↦→ λ∥u∥2. GS and W are convex and differentiable\nfunctions. Since the Bregman divergence is non-negative, BGS ≥ 0 and BFS = BW + BGS ≥ BW .\nSimilarly, BFS′ ≥ BW . Thus, the following inequality holds:\nBW (w′∥w)+ BW (w∥w′) ≤ BFS (w′∥w)+ BFS′ (w∥w′). (6)\nBy the deﬁnition of w and w′ as the minimizers of FS and FS′ , ∇FS (w)= ∇FS′ (w′)= 0 and\nBFS (w′∥w)+ BFS′ (w∥w′)= FS (w′) − FS (w)+ FS′ (w) − FS′ (w′)\n= 1\nm\n[[\nLzm (w′) − Lzm (w)\n]\n+\n[\nLz′m (w) − Lz′m (w′)\n]]\n≤− 1\nm\n[\n∇Lzm (w′) · (w − w′)+ ∇Lz′\nm (w) · (w′ − w)\n]\n= − 1\nm\n[\n∇Lz′m (w) −∇ Lzm (w′)\n]\n· (w′ − w),\nwhere we used the convexity of Lz′m and Lzm . It is not hard to see that BW (w′∥w)+ BW (w∥w′)=\n2λ∥∆w∥2. Thus, the application of the Cauchy-Schwarz inequality to the inequality just established\nyields\n2λ ∥∆w∥≤ 1\nm ∥∇Lzm (w′) −∇ Lz′m (w)∥≤ 1\nm\n[\n∥∇Lzm (w′)∥ + ∥∇Lz′m (w)∥\n]\n. (7)\nThe gradient of w ↦→ Lzm (w) = log ∑\ny∈Y ew·Φ(xm,y) −w · Φ(xm,y m) is given by\n∇Lzm (w)=\n∑\ny∈Y ew·Φ(xm,y)Φ(xm,y )\n∑\ny′∈Y ew·Φ(xm,y′) − Φ(xm,y m) = E\ny∼pw [·|xm]\n[\nΦ(xm,y ) − Φ(xm,y m)\n]\n.\nThus, we obtain ∥∇Lzm (w′)∥≤ Ey∼pw′ [·|xm]\n[\n∥Φ(xm,y ) − Φ(xm,y m)∥\n]\n≤ 2R and similarly\n∥∇Lz′m (w)∥≤2 R, which leads to the statement of the theorem.\nLet D denote the distribution according to which training and test points are drawn and let F ⋆ be\nthe objective function associated to the optimization deﬁned with respect to the true log loss:\nF ⋆(w) = argmin\nw∈H\nλ∥w∥2 +E\nz∼D\n[\nLz (w)\n]\n. (8)\nF ⋆ is a convex function since ED[Lz ] is convex. Let the solution of this optimization be denoted by\nw⋆ = argminw∈H F ⋆(w).\nTheorem 2. Let w ∈ H be the weight vector returned by conditional maximum entropy when\ntrained on a sample S of size m. Then, for any δ> 0, with probability at least 1−δ, the following\ninequality holds:\n∥w − w⋆∥≤ R\nλ\n√\nm/2\n(\n1+\n√\nlog 1/δ\n)\n. (9)\nProof. Let S and S′ be as before samples of size m differing by a single point. To derive this\nbound, we apply McDiarmid’s inequality [17] to Ψ(S)= ∥w − w⋆∥. By the triangle inequality and\nTheorem 1, the following Lipschitz property holds:\n|Ψ(S′) − Ψ(S)| =\n⏐⏐∥w′ − w⋆∥ − ∥w − w⋆∥\n⏐\n⏐ ≤∥ w\n′ − w∥≤ 2R\nλm . (10)\n5\nThus, by McDiarmid’s inequality, Pr[Ψ−E[Ψ] ≥ ϵ] ≤ exp\n(−2ϵ2m\n4R2 /λ2\n)\n. The following bound can be\nshown for the expectation of Ψ (see longer version of this paper): E[Ψ] ≤ 2R\nλ\n√\n2m . Using this bound\nand setting the right-hand side of McDiarmid’s inequality to δ show that the following holds\nΨ ≤ E[Ψ] + 2R\nλ\n√\nlog 1\nδ\n2m ≤ 2R\nλ\n√\n2m\n(\n1+\n√\nlog 1/δ\n)\n, (11)\nwith probability at least 1−δ.\nNote that, remarkably, the bound of Theorem 2 does not depend on the dimension of the feature\nspace but only on the radius R of the sphere containing the feature vectors.\nConsider now a sample S =( S1,...,S p) of pm points formed by p subsamples of m points drawn\ni.i.d. and let wµ denote the µ-mixture weight as deﬁned in Section 2.4. The following theorem gives\na learning bound for wµ.\nTheorem 3. F or anyµ ∈ ∆p, let wµ ∈ H denote the mixture weight vector obtained from a sample\nof size pm by combining the p weight vectors wk, k ∈ [1,p ], each returned by conditional maximum\nentropy when trained on the sample Sk of size m. Then, for any δ> 0, with probability at least 1−δ,\nthe following inequality holds:\n∥wµ − w⋆∥≤ E\n[\n∥wµ − w⋆∥\n]\n+ R∥µ∥\nλ\n√\nm/2\n√\nlog 1/δ. (12)\nF or the uniform mixtureµ0 = (1/p, . . . ,1/p), the bound becomes\n∥wµ − w⋆∥≤ E\n[\n∥wµ − w⋆∥\n]\n+ R\nλ\n√\npm/2\n√\nlog 1/δ. (13)\nProof. The result follows by application of McDiarmid’s inequality to Υ(S)= ∥wµ − w⋆∥. Let\nS′ =( S′\n1, . . . , S′\np) denote a sample differing from S by one point, say in subsample Sk. Let w′\nk\ndenote the weight vector obtained by training on subsample S′\nk and w′\nµ the mixture weight vector\nassociated to S′. Then, by the triangle inequality and the stability bound of Theorem 1, the following\nholds:\n|Υ(S′) − Υ(S)| =\n⏐⏐∥w′\nµ − w⋆∥ − ∥wµ − w⋆∥\n⏐\n⏐ ≤∥ w\n′\nµ − wµ∥ = µk∥w′\nk − wk∥≤ 2µkR\nλm .\nThus, by McDiarmid’s inequality,\nPr[Υ(S) − E[Υ(S)] ≥ ϵ] ≤ exp\n( −2ϵ2\n∑p\nk=1 m\n(2µk R\nλm\n)2\n)\n= exp\n( −2λ2mϵ2\n4R2∥µ∥2\n)\n, (14)\nwhich proves the ﬁrst statement and the uniform mixture case since ∥µ0∥ =1 /√\np.\nTheorems 2 and 3 help us compare the mixture weight wpm obtained by training on a sample of\nsize pm versus the mixture weight vector wµ0 . The regularization parameter λ is a function of\nthe sample size. To simplify the analysis, we shall assume th at λ = O(1/m1/4) for a sample of\nsize m. A similar discussion holds for other comparable asymptotic behaviors. By Theorem 2,\n∥wpm − w⋆∥ converges to zero in O(1/(λ√\npm)) = O(1/(pm)1/4), since λ = O(1/(pm)1/4) in\nthat case. But, by Theorem 3, the slack term bounding ∥wµ0 − w⋆∥ converges to zero at the faster\nrate O(1/(λ√\npm)) =O(1/p1/2m1/4), since here λ = O(1/m1/4). The expectation term appearing\nin the bound on ∥wµ0 − w⋆∥, E[∥wµ0 − w⋆∥], does not beneﬁt from the same convergence rate\nhowever. E[∥wµ0 − w⋆∥] converges always as fast as the expectation E[∥wm − w⋆∥] for a weight\nvector wm obtained by training on a sample of size m since, by the triangle inequality, the following\nholds:\nE[∥wµ − w⋆∥] = E[ ∥ 1\np\np∑\nk=1\n(wk − w⋆)∥] ≤ 1\np\np∑\nk=1\nE[∥wk − w⋆∥] = E[ ∥w1 − w⋆∥]. (15)\nBy the proof of Theorem 2, E[∥w1 −w⋆∥] ≤ R/(λ\n√\nm/2) = O(1/(λ√\nm)), thus E[∥wµ −w⋆∥] ≤\nO(1/m1/4). In summary, wµ0 always converges signiﬁcantly faster than wm. The convergence\nbound for wµ0 contains two terms, one somewhat more favorable, one somewhat less than its coun-\nterpart term in the bound for wpm.\n6\npm\n |Y|\n |X |\n sparsity\n p\nEnglish POS [16]\n 1M\n 24\n 500 K\n 0.001\n 10\nSentiment\n 9M\n 3\n 500 K\n 0.001\n 10\nRCV1-v2 [14]\n 26 M\n 103\n 10 K\n 0.08\n 10\nSpeech\n 50 M\n 129\n 39\n 1.0\n 499\nDeja News Archive\n 306 M\n 8\n 50 K\n 0.002\n 200\nDeja News Archive 250K\n 306 M\n 8\n 250 K\n 0.0004\n 200\nGigaword [10]\n 1,000 M\n 96\n 10 K\n 0.001\n 1000\nTable 2: Description of data sets. The column named sparsity reports the frequency of non-zero\nfeature values for each data set.\n4 Experiments\nWe ran a number of experiments on data sets ranging in size from 1M to 1B labeled instances (see\nTable 2) to compare the three distributed training methods described in Section 2. Our experiments\nwere carried out using a large cluster of commodity machines with a local shared disk space and a\nhigh rate of connectivity between each machine and between machines and disk. Thus, while the\nprocesses did not run on one multi-core supercomputer, the network latency between machines was\nminimized.\nWe report accuracy, wall clock, cumulative CPU usage, and cumulative network usage for all of our\nexperiments. Wall clock measures the combined effects of the user CPU and latency costs (column\n1 of Table 1), and includes the total time for training, including all summations. Network usage\nmeasures the amount of data transferred across the network. Due to the set-up of our cluster, this\nincludes both machine-to-machine trafﬁc and machine-to-disk trafﬁc. The resource estimates were\ncalculated by point-sampling and integrating over the sampling time. For all three methods, we used\nthe same base implementation of conditional maximum entropy, modiﬁed only in whether or not the\ngradient was computed in a distributed fashion.\nOur ﬁrst set of experiments were carried out with “medium” scale data sets containing 1M-300M in-\nstances. These included: English part-of-speech tagging, generated from the Penn Treebank\n[16] using the ﬁrst character of each part-of-speech tag as output, sections 2-21 for training, section\n23 for testing and a feature representation based on the identity, afﬁxes, and orthography of the in-\nput word and the words in a window of size two; Sentiment analysis , generated from a set of\nonline product, service, and merchant reviews with a three-label output (positive, negative, neutral),\nwith a bag of words feature representation; RCV1-v2 as described by [14], where documents having\nmultiple labels were included multiple times, once for each label; Acoustic Speech Data , a 39-\ndimensional input consisting of 13 PLP coefﬁcients, plus their ﬁrst and second derivatives, and 129\noutputs (43 phones × 3 acoustic states); and the Deja News Archive , a text topic classiﬁcation\nproblem generated from a collection of Usenet discussion forums from the years 1995-2000. For all\ntext experiments, we used random feature mixing [9, 20] to control the size of the feature space.\nThe results reported in Table 3 show that the accuracy of the mixture weight method consistently\nmatches or exceeds that of the majority vote method. As expected, the resource costs here are\nsimilar, with slight differences due to the point-sampling methods and the overhead associated with\nstoring p models in memory and writing them to disk. For some data sets, we could not report\nmajority vote results as all models could not ﬁt into memory on a single machine.\nThe comparison shows that in some cases the mixture weight method takes longer and achieves\nsomewhat better performance than the distributed gradient method while for other data sets it ter-\nminates faster, at a slight loss in accuracy. These differences may be due to the performance of the\noptimization with respect to the regularization parameter λ. However, the results clearly demon-\nstrate that the mixture weight method achieves comparable accuracies at a much decreased cost in\nnetwork bandwidth – upwards of 1000x. Depending on the cost model assessed for the underlying\nnetwork and CPU resources, this may make mixture weight a signiﬁcantly more appealing strategy.\nIn particular, if network usage leads to signiﬁcant increases in latency, unlike our current experi-\nmental set-up of high rates of connectivity, then the mixture weight method could be substantially\nfaster to train. The outlier appears to be the acoustic speech data, where both mixture weight and\ndistributed gradient have comparable network usage, 158GB and 200GB, respectively. However, the\nbulk of this comes from the fact that the data set itself is 157GB in size, which makes the network\n7\nTraining Method\n Accuracy\n Wall Clock\n Cumulative CPU\n Network Usage\nEnglish POS\n Distributed Gradient\n 97.60%\n 17.5 m\n 11.0 h\n 652 GB\n(m=100k,p=10)\n Majority V ote\n 96.80%\n 12.5 m\n 18.5 h\n 0.686 GB\nMixture Weight\n 96.80%\n 5m\n 11.5 h\n 0.015 GB\nSentiment\n Distributed Gradient\n 81.18%\n 104 m\n 123 h\n 367 GB\n(m=900k,p=10)\n Majority V ote\n 81.25%\n 131 m\n 168 h\n 3 GB\nMixture Weight\n 81.30%\n 110 m\n 163 h\n 9 GB\nRCV1-v2\n Distributed Gradient\n 27.03%\n 48 m\n 407 h\n 479 GB\n(m=2.6M,p=10)\n Majority V ote\n 26.89%\n 54 m\n 474 h\n 3 GB\nMixture Weight\n 27.15%\n 56 m\n 473 h\n 0.108 GB\nSpeech\n Distributed Gradient\n 34.95%\n 160 m\n 511 h\n 200 GB\n(m=100k,p=499)\n Mixture Weight\n 34.99%\n 130 m\n 534 h\n 158 GB\nDeja\n Distributed Gradient\n 64.74%\n 327 m\n 733 h\n 5,283 GB\n(m=1.5M,p=200)\n Mixture Weight\n 65.46%\n 316 m\n 707 h\n 48 GB\nDeja 250K\n Distributed Gradient\n 67.03%\n 340 m\n 698 h\n 17,428 GB\n(m=1.5M,p=200)\n Mixture Weight\n 66.86%\n 300 m\n 710 h\n 65 GB\nGigaword\n Distributed Gradient\n 51.16%\n 240 m\n 18,598 h\n 13,000 GB\n(m=1M,p=1k)\n Mixture Weight\n 50.12%\n 215 m\n 17,998 h\n 21 GB\nTable 3: Accuracy and resource costs for distributed training strategies.\nusage closer to 1GB for the mixture weight and 40GB for distributed gradient method when we\ndiscard machine-to-disk trafﬁc.\nFor the largest experiment, we examined the task of predicting the next character in a sequence\nof text [19], which has implications for many natural language processing tasks. As a training\nand evaluation corpus we used the English Gigaword corpus [10] and used the full ASCII output\nspace of that corpus of around 100 output classes (uppercase and lowercase alphabet characters\nvariants, digits, punctuation, and whitespace). For each character s, we designed a set of observed\nfeatures based on substrings from s−1, the previous character, to s−10, 9 previous characters, and\nhashed each into a 10k-dimensional space in an effort to improve speed. Since there were around\n100 output classes, this led to roughly 1M parameters. We then sub-sampled 1B characters from\nthe corpus as well as 10k testing characters and established a training set of 1000 subsets, of 1M\ninstances each. For the experiments described above, the regularization parameter λ was kept ﬁxed\nacross the different methods. Here, we decreased the parameter λ for the distributed gradient method\nsince less regularization was needed when more data was available, and since there were three orders\nof magnitude difference between the training size for each independent model and the distributed\ngradient. We compared only the distributed gradient and mixture weight methods since the majority\nvote method exceeded memory capacity. On this data set, the network usage is on a different scale\nthan most of the previous experiments, though comparable to Deja 250, with the distributed gradient\nmethod transferring 13TB across the network. Overall, the mixture weight method consumes less\nresources: less bandwidth and less time (both wall clock and CPU). With respect to accuracy, the\nmixture weight method does only slightly worse than the distributed gradient method. The individual\nmodels in the mixture weight method ranged between 49.73% to 50.26%, with a mean accuracy\nof 50.07%, so a mixture weight model improves slightly over a random subsample models and\ndecreases the overall variance.\n5 Conclusion\nOur analysis and experiments give signiﬁcant support for the mixture weight method for training\nvery large-scale conditional maximum entropy models with L2 regularization. Empirical results\nsuggest that this method achieves similar or better accuracies while reducing network usage by\nabout three orders of magnitude and modestly reducing the wall clock time, typically by about 15%\nor more. In distributed environments without a high rate of connectivity, the decreased network\nusage of the mixture weight method should lead to substantial gains in wall clock as well.\nAcknowledgments\nWe thank Yishay Mansour for his comments on an earlier version of this paper.\n8\nReferences\n[1] A. Berger, V . Della Pietra, and S. Della Pietra. A maximum entropy approach to natural\nlanguage processing. Computational Linguistics, 22(1):39–71, 1996.\n[2] O. Bousquet and A. Elisseeff. Stability and generalization. Journal of Machine Learning\nResearch, 2:499–526, 2002.\n[3] S. F. Chen and R. Rosenfeld. A survey of smoothing techniques for ME models. IEEE Trans-\nactions on Speech and Audio Processing , 8(1):37–50, 2000.\n[4] C. Chu, S. Kim, Y . Lin, Y . Y u, G. Bradski, A. Ng, and K. Olukotun. Map-Reduce for machine\nlearning on multicore. In Advances in Neural Information Processing Systems , 2007.\n[5] M. Collins, R. Schapire, and Y . Singer. Logistic regression, AdaBoost and Bregman distances.\nMachine Learning, 48, 2002.\n[6] C. Cortes, M. Mohri, M. Riley, and A. Rostamizadeh. Sample selection bias correction theory.\nIn Proceedings of ALT 2008 , volume 5254 of LNCS, pages 38–53. Springer, 2008.\n[7] J. Darroch and D. Ratcliff. Generalized iterative scaling for log-linear models. The Annals of\nMathematical Statistics, pages 1470–1480, 1972.\n[8] S. Della Pietra, V . Della Pietra, J. Lafferty, R. Technol, and S. Brook. Inducing features of\nrandom ﬁelds. IEEE transactions on pattern analysis and machine intelligence , 19(4):380–\n393, 1997.\n[9] K. Ganchev and M. Dredze. Small statistical models by random feature mixing. In W orkshop\non Mobile Language Processing, ACL, 2008.\n[10] D. Graff, J. Kong, K. Chen, and K. Maeda. English gigaword third edition, linguistic data\nconsortium, philadelphia, 2007.\n[11] E. T. Jaynes. Information theory and statistical mechanics. Physical Review, 106(4):620630,\n1957.\n[12] J. Jeon and R. Manmatha. Using maximum entropy for automatic image annotation. In Inter-\nnational Conference on Image and Video Retrieval , 2004.\n[13] G. Lebanon and J. Lafferty. Boosting and maximum likelihood for exponential models. In\nAdvances in Neural Information Processing Systems , pages 447–454, 2001.\n[14] D. Lewis, Y . Y ang, T. Rose, and F. Li. RCV1: A new benchmark collection for text catego-\nrization research. Journal of Machine Learning Research , 5:361–397, 2004.\n[15] R. Malouf. A comparison of algorithms for maximum entropy parameter estimation. In Inter-\nnational Conference on Computational Linguistics (COLING) , 2002.\n[16] M. Marcus, M. Marcinkiewicz, and B. Santorini. Building a large annotated corpus of English:\nThe Penn Treebank. Computational linguistics, 19(2):313–330, 1993.\n[17] C. McDiarmid. On the method of bounded differences. In Surveys in Combinatorics , pages\n148–188. Cambridge University Press, Cambridge, 1989.\n[18] J. Nocedal and S. Wright. Numerical optimization. Springer, 1999.\n[19] C. E. Shannon. Prediction and entropy of printed Englis h. Bell Systems T echnical Journal,\n30:50–64, 1951.\n[20] K. Weinberger, A. Dasgupta, J. Langford, A. Smola, and J. Attenberg. Feature hashing for\nlarge scale multitask learning. In International Conference on Machine Learning , 2009.\n[21] T. Zhang. Solving large scale linear prediction problems using stochastic gradient descent\nalgorithms. In International Conference on Machine Learning , 2004.\n9",
  "values": {
    "Interpretable (to users)": "No",
    "Respect for Persons": "No",
    "User influence": "No",
    "Privacy": "No",
    "Fairness": "No",
    "Respect for Law and public interest": "No",
    "Collective influence": "No",
    "Not socially biased": "No",
    "Transparent (to users)": "No",
    "Non-maleficence": "No",
    "Justice": "No",
    "Explicability": "No",
    "Beneficence": "No",
    "Critiqability": "No",
    "Autonomy (power to decide)": "No",
    "Deferral to humans": "No"
  }
}