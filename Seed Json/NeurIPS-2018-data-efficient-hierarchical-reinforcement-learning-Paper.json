{
  "pdf": "NeurIPS-2018-data-efficient-hierarchical-reinforcement-learning-Paper",
  "title": "Data-Efficient Hierarchical Reinforcement Learning",
  "author": "Ofir Nachum, Shixiang (Shane) Gu, Honglak Lee, Sergey Levine",
  "paper_id": "NeurIPS-2018-data-efficient-hierarchical-reinforcement-learning-Paper",
  "text": "Data-Efﬁcient Hierarchical Reinforcement Learning\nOﬁr Nachum\nGoogle Brain\nofirnachum@google.com\nShixiang Gu∗\nGoogle Brain\nshanegu@google.com\nHonglak Lee\nGoogle Brain\nhonglak@google.com\nSergey Levine†\nGoogle Brain\nslevine@google.com\nAbstract\nHierarchical reinforcement learning (HRL) is a promising approach to extend\ntraditional reinforcement learning (RL) methods to solve more complex tasks.\nYet, the majority of current HRL methods require careful task-speciﬁc design and\non-policy training, making them difﬁcult to apply in real-world scenarios. In this\npaper, we study how we can develop HRL algorithms that are general, in that they\ndo not make onerous additional assumptions beyond standard RL algorithms, and\nefﬁcient, in the sense that they can be used with modest numbers of interaction\nsamples, making them suitable for real-world problems such as robotic control. For\ngenerality, we develop a scheme where lower-level controllers are supervised with\ngoals that are learned and proposed automatically by the higher-level controllers.\nTo address efﬁciency, we propose to use off-policy experience for both higher-\nand lower-level training. This poses a considerable challenge, since changes to\nthe lower-level behaviors change the action space for the higher-level policy, and\nwe introduce an off-policy correction to remedy this challenge. This allows us\nto take advantage of recent advances in off-policy model-free RL to learn both\nhigher- and lower-level policies using substantially fewer environment interactions\nthan on-policy algorithms. We term the resulting HRL agent HIRO and ﬁnd that\nit is generally applicable and highly sample-efﬁcient. Our experiments show that\nHIRO can be used to learn highly complex behaviors for simulated robots, such\nas pushing objects and utilizing them to reach target locations, 1 learning from\nonly a few million samples, equivalent to a few days of real-time interaction. In\ncomparisons with a number of prior HRL methods, we ﬁnd that our approach\nsubstantially outperforms previous state-of-the-art techniques.2\n1 Introduction\nDeep reinforcement learning (RL) has made signiﬁcant progress on a range of continuous control\ntasks, such as locomotion skills [35, 25, 17], learning dexterous manipulation behaviors [33], and\ntraining robot arms for simple manipulation tasks [13, 41]. However, most of these behaviors are\ninherently atomic: they require performing some simple skill, either episodically or cyclically, and\nrarely involve complex multi-level reasoning, such as utilizing a variety of locomotion behaviors to\naccomplish complex goals that require movement, object interaction, and discrete decision-making.\n∗Also at University of Cambridge; Max Planck Institute of Intelligent Systems.\n†Also at UC Berkeley.\n1See videos at https://sites.google.com/view/efficient-hrl\n2Find open-source code at https://github.com/tensorflow/models/tree/master/research/\nefficient-hrl\n32nd Conference on Neural Information Processing Systems (NeurIPS 2018), Montréal, Canada.\nFigure 1: The Ant Gather task along with the three hierarchical navigation tasks we consider:\nAnt Maze, Ant Push, and Ant Fall. The ant (magenta rectangle) is rewarded for approaching the\ntarget location (green arrow). A successful policy must perform a complex sequence of directional\nmovement and, in some cases, interact with objects in its environment (red blocks); e.g., pushing aside\nan obstacle (second from right) or using a block as a bridge (right). In our HRL method, a higher-level\npolicy periodically produces goal states (corresponding to desired positions and orientations of the\nant and its limbs), which the lower-level policy is rewarded to match (blue arrow).\nHierarchical reinforcement learning (HRL), in which multiple layers of policies are trained to perform\ndecision-making and control at successively higher levels of temporal and behavioral abstraction, has\nlong held the promise to learn such difﬁcult tasks [7, 29, 39, 4]. By having a hierarchy of policies,\nof which only the lowest applies actions to the environment, one is able to train the higher levels\nto plan over a longer time scale. Moreover, if the high-level actions correspond to semantically\ndifferent low-level behavior, standard exploration techniques may be applied to more appropriately\nexplore a complex environment. Still, there is a large gap between the basic deﬁnition of HRL\nand the promise it holds to successfully solve complex environments. To achieve the beneﬁts of\nHRL, there are a number of questions that one must suitably answer: How should one train the\nlower-level policy to induce semantically distinct behavior? How should the high-level policy actions\nbe deﬁned? How should the multiple policies be trained without incurring an inordinate amount\nof experience collection? Previous work has attempted to answer these questions in a variety of\nways and has provided encouraging successes [43, 10, 11, 18, 36]. However, many of these methods\nlack generality, requiring some degree of manual task-speciﬁc design, and often require expensive\non-policy training that is unable to beneﬁt from advances in off-policy model-free RL, which in\nrecent years has drastically brought down sample complexity requirements [12, 15, 3].\nFor generality, we propose to take advantage of the state observation provided by the environment\nto the agent, which in locomotion tasks can include the position and orientation of the agent and its\nlimbs. We let the high-level actions be goal states and reward the lower-level policy for performing\nactions which yield it an observation close to matching the desired goal. In this way, our HRL setup\ndoes not require a manual or multi-task design and is fully general.\nThis idea of a higher-level policy commanding a lower-level policy to match observations to a goal\nstate has been proposed before [7, 43]. Unlike previous work, which represented goals and rewarded\nmatching observations within a learned embedding space, we use the state observations in their\nraw form. This signiﬁcantly simpliﬁes the learning, and in our experiments, we observe substantial\nbeneﬁts for this simpler approach.\nWhile these goal-proposing methods are very general, they require training with on-policy RL\nalgorithms, which are generally less efﬁcient than off-policy methods [14, 28]. On-policy training\nhas been attractive in the past since, outside of discrete control, off-policy methods have been plagued\nwith instability [14], which is ampliﬁed when training multiple policies jointly, as in HRL. Other than\ninstability, off-policy training poses another challenge that is unique to HRL. Since the lower-level\npolicy is changing underneath the higher-level policy, a sample observed for a certain high-level\naction in the past may not yield the same low-level behavior in the future, and thus not be a valid\nexperience for training. This amounts to a non-stationary problem for the higher-level policy. We\nremedy this issue by introducing an off-policy correction, which re-labels an experience in the past\nwith a high-level action chosen to maximize the probability of the past lower-level actions. In this way,\nwe are able to use past experience for training the higher-level policy, taking advantage of progress\nmade in recent years to provide stable, robust, and general off-policy RL methods [12, 28, 3].\nIn summary, we introduce a method to train a multi-level HRL agent that stands out from previous\nmethods by being both generally applicable and data-efﬁcient. Our method achieves generality by\ntraining the lower-level policy to reach goal states learned and instructed by the higher-levels. In\ncontrast to prior work that operates in this goal-setting model, we use states as goals directly, which\nallows for simple and fast training of the lower layer. Moreover, by using off-policy training with\n2\nour novel off-policy correction, our method is extremely sample-efﬁcient. We evaluate our method\non several difﬁcult environments. These environments require the ability to perform exploratory\nnavigation as well as complex sequences of interaction with objects in the environment (see Figure 1).\nWhile these tasks are unsolvable by existing non-HRL methods, we ﬁnd that our HRL setup can\nlearn successful policies. When compared to other published HRL methods, we also observe the\nsuperiority of our method, in terms of both ﬁnal performance and speed of learning. In only a few\nmillion experience samples, our agents are able to adequately solve previously unapproachable tasks.\n2 Background\nWe adopt the standard continuous control RL setting, in which an agent interacts with an environment\nover periods of time according to a behavior policyµ. At each time step t, the environment produces\na state observation st∈ Rds.The agent then samples an action at∼ µ(st),at∈ Rdaand applies\nthe action to the environment. The environment then yields a rewardRt sampled from an unknown\nreward functionR(st,at) and either terminates the episode at statesT or transitions to a new state\nst+1 sampled from an unknown transition functionf (st,at). The agent’s goal is to maximize the\nexpected future discounted reward Es0:T,a0:T −1,R0:T −1\n[∑T−1\ni=0 γiRi\n]\n, where 0≤ γ < 1 is a user-\nspeciﬁed discount factor. A well-performing RL algorithm will learn a good behavior policyµ from\n(ideally a small number of) interactions with the environment.\n2.1 Off-Policy Temporal Difference Learning\nTemporal difference learning is a powerful paradigm in RL, in which a policy may be learned\nefﬁciently from state-action-reward transition tuples (st,at,Rt,st+1) collected from interactions\nwith the environment. In our HRL method, we utilize the TD3 learning algorithm [12], a variant of\nthe popular DDPG algorithm for continuous control [25].\nIn DDPG, a deterministic neural network policy µφ is learned along with its corresponding state-\naction Q-functionQθ by performing gradient updates on parameter sets φ andθ. The Q-function\nrepresents the future value of taking a speciﬁc actionat starting from a statest. Accordingly, it is\ntrained to minimize the average Bellman error over all sampled transitions, which is given by\nE(st,at,st+1) = (Qθ(st,at)−Rt−γQθ(st+1,µφ(st+1)))2. (1)\nThe policy is then trained to yield actions which maximize the Q-value at each state. That is,µφ is\ntrained to maximizeQθ(st,µφ(st)) over allst collected from interactions with the environment.\nWe note that although DDPG trains a deterministic policyµφ, its behavior policy, which is used to\ncollect experience during training is augmented with Gaussian (or Ornstein-Uhlenbeck) noise [25].\nTherefore, actions are collected asat∼N (µφ(st),σ ) for ﬁxed standard deviationσ, which we will\nshorten asat∼µφ(st). We will take advantage of the fact that the behavior policy is stochastic for\nthe off-policy correction in our HRL method. TD3 [ 12] makes several modiﬁcations to DDPG’s\nlearning algorithm to yield a more robust and stable procedure. Its main modiﬁcation is using an\nensemble over Q-value models and adding noise to the policy when computing the target value in\nEquation 1.\n3 General and Efﬁcient Hierarchical Reinforcement Learning\nIn this section, we present our framework for learning hierarchical policies, HIRO: HIerarchical\nReinforcement learning with Off-policy correction. We make use of parameterized reward functions\nto specify a potentially inﬁnite set of lower-level policies, each of which is trained to match its\nobserved states st to a desired goal. The higher-level policy chooses these goals for temporally\nextended periods, and uses an off-policy correction to enable it to use past experience collected from\nprevious, different instantiations of the lower-level policy.\n3.1 Hierarchy of Two Policies\nWe extend the standard RL setup to a hierarchical two-layer structure, with a lower-level policy\nµlo and a higher-level policyµhi (see Figure 2). The higher-level policy operates at a coarser layer\n3\nμlo\n        Environment                                                                    \nμhi\ng0\na0\ns0\nμlo\na1\ns1\nμlo\nac - 1\nsc - 1\nμlo\nμhi\ngc\nac\nsc\ng1\nh gc - 1\nh\nR0 R1 Rc-1 Rc\nOff-policy training with \nrespect to goal-conditioned \nrewards r(st, gt, at, st+1).\nPrincipled off-policy \ntraining with goal \nre-labelling.\n. . .\n. . .\n. . .\n1. Collect experience st,gt,at,Rt,... .\n2. Train µlo with experience transitions\n(st,g t,a t,r t,s t+1,g t+1) using gt as\nadditional state observation and reward given by\ngoal-conditioned functionrt =\nr(st,g t,a t,s t+1) =−||st +gt−st+1||2.\n3. Train µhi on temporally-extended experience\n(st, ˜gt, ∑Rt:t+c−1,s t+c), where ˜gt is re-\nlabelled high-level action to maximize probability\nof past low-level actionsat:t+c−1.\n4. Repeat.\nFigure 2: The design and basic training of HIRO. The lower-level policy interacts directly with the\nenvironment. The higher-level policy instructs the lower-level policy via high-level actions, or goals,\ngt∈ Rds which it samples anew everyc steps. On intermediate steps, a ﬁxed goal transition function\nh determines the next step’s goal. The goal simply instructs the lower-level policy to reach speciﬁc\nstates, which allows the lower-level policy to easily learn from prior off-policy experience.\nFigure 3: An example of a higher-level policy producing goals in terms of desired observations,\nwhich in this task correspond to positions and orientations of all of the joints of a quadrupedal robot\n(including root position). The lower-level policy has direct control of the agent (pink), and is rewarded\nfor matching the position and orientation of its torso and each limb to the goal (blue rectangle, raised\nfor visibility). In this way, the two-layer policy can perform a complex task involving a sequence of\nmovements and interactions; e.g. pushing a block aside to reach a target (green).\nof abstraction and sets goals to the lower-level policy, which correspond directly to states that the\nlower-level policy attempts to reach. At each time stept, the environment provides an observation\nstatest. The higher-level policy observes the state and produces ahigh-level action (or goal)gt∈ Rds\nby either sampling from its policygt∼µhi whent≡ 0 (mod c), or otherwise using a ﬁxed goal\ntransition functiongt =h(st−1,gt−1,st) (which in the simplest case can be a pass-through function,\nalthough we will consider a slight variation in our speciﬁc design). This provides temporal abstraction,\nsince high-level decisions viaµhi are made only everyc steps. The lower-level policyµlo observes\nthe statest and goalgt and produces a low-level atomic actionat∼ µlo(st,gt), which is applied\nto the environment. The environment then yields a reward Rt sampled from an unknown reward\nfunctionR(st,at) and transitions to a new statest+1 sampled from an unknown transition function\nf (st,at).\nThe higher-level controller provides the lower-level with an intrinsic rewardrt =r(st,gt,at,st+1),\nusing a ﬁxed parameterized reward function r. The lower-level policy will store the expe-\nrience (st,gt,at,rt,st+1,h (st,gt,st+1)) for off-policy training. The higher-level policy col-\nlects the environment rewards Rt and, every c time steps, stores the higher-level transition\n(st:t+c−1,gt:t+c−1,at:t+c−1,Rt:t+c−1,st+c) for off-policy training.\n3.2 Parameterized Rewards\nOur higher-level policy produces goalsgt indicating desired relative changes in state observations.\nThat is, at stept, the higher-level policy produces a goalgt, indicating its desire for the lower-level\nagent to take actions that yield it an observationst+c that is close tost +gt. Although some state\ndimensions (e.g., the position of the quadrupedal robot in Figure 3) are more natural as goal subspaces,\nwe chose this more generic goal representation to make it broadly applicable, without any manual\ndesign of goal spaces, primitives, or controllable dimensions. This makes our method general and\n4\neasy to apply to new problem settings. To maintain the same absolute position of the goal regardless\nof state change, the goal transition modelh is deﬁned as\nh(st,gt,st+1) = st +gt−st+1. (2)\nWe deﬁne the intrinsic reward as a parameterized reward function based on the distance between the\ncurrent observation and the goal observation:\nr(st,gt,at,st+1) =−||st +gt−st+1||2. (3)\nThis rewards the lower-level policy for taking actions that yield observations that are close to\nthe desired value st +gt. In our evaluations on simulated ant locomotion, we use all positional\nobservations as the representation forgt, without distinguishing between the (x,y,z ) root position\nor the joints, making for a generic and broadly applicable choice of goal space. The reward r and\ntransition functionh are computed only with respect to these positional observations. See Figure 3\nfor an example of the goalsgt chosen during a successful navigation of a complex environment.\nThe lower-level policy may be trained using standard methods by simply incorporating gt as an\nadditional input into the value and policy models. For example, in DDPG, the equivalent objective to\nEquation 1 in terms of lower-level Q-value functionQlo\nθ is to minimize the error\n(Qlo\nθ (st,gt,at)−r(st,gt,at,st+1)−γQlo\nθ (st+1,gt+1,µlo\nφ (st+1,gt+1)))2, (4)\nfor all transitions (st,gt,at,st+1,gt+1). The policyµlo\nφ would be trained to maximize the Q-value\nQlo\nθ (st,gt,µlo\nφ (st,gt)) for all sampled state-goal tuples (st,gt).\nParameterized rewards are not a new concept, and have been studied previously [34, 19]. They are a\nnatural choice for a generally applicable HRL method and have therefore appeared as components\nof other HRL methods [ 43, 22, 30, 24]. A signiﬁcant distinction between our method and these\nprior approaches is that we directly use the state observation as the goal, and changes in the state\nobservation as the action space for the higher-level policy, in contrast to prior methods that must\ntrain the goal representation. This allows the lower-level policy to begin receiving reward signals\nimmediately, even before the lower-level policy has ﬁgured out how to reach the goal and before the\ntask’s extrinsic reward provides any meaningful supervision. In our experiments (Section 5), we ﬁnd\nthat this produces substantially better results.\n3.3 Off-Policy Corrections for Higher-Level Training\nWhile a number of prior works have proposed two-level HRL architectures that involve some sort of\ngoal setting, such designs in previous work generally require on-policy training [43]. This is because\nthe changing behavior of the lower-level policy creates a non-stationary problem for the higher-level\npolicy, and old off-policy experience may exhibit different transitions conditioned on the same goals.\nHowever, for HRL methods to be applicable to real-world settings, they must be sample-efﬁcient,\nand off-policy algorithms (often based on some variant of Q-function learning) generally exhibit\nsubstantially better sample efﬁciency than on-policy actor-critic or policy gradient variants. In this\nsection, we describe how we address the challenge of off-policy training of the higher-level policy.\nWe would like to take the higher-level transition tuples(st:t+c−1,gt:t+c−1,at:t+c−1,Rt:t+c−1,st+c),\nwherext:t+c−1 denotes the sequencext,...,x t+c−1, which are collected by the higher-level policy\nand convert them to state-action-reward transitions (st,gt, ∑Rt:t+c−1,st+c) that can be pushed\ninto the replay buffer of any standard off-policy RL algorithm. However, since transitions obtained\nfrom past lower-level controllers do not accurately reﬂect the actions (and therefore resultant states\nst+1:t+c) that would occur if the same goal were used with the current lower-level controller, we must\nintroduce a correction that translates old transitions into ones that agree with the current lower-level\ncontroller.\nOur main observation is that the goalgt of a past high-level transition (st,gt, ∑Rt:t+c−1,st+c) may\nbe changed to make the actual observed action sequence more likely to have happened with respect\nto the current instantiation of µlo. The high-level action gt which in the past induced a low-level\nbehaviorat:t+c−1∼µlo(st:t+c−1,gt:t+c−1) may be re-labeled to a goal ˜gt which is likely to induce\nthe same low-level behavior with the current instantiation of the lower-level policy. Thus, we propose\nto remedy the off-policy issue by re-labeling the high-level transition (st,gt, ∑Rt:t+c−1,st+c) with\na different high-level action ˜gt chosen to maximize the probabilityµlo(at:t+c−1|st:t+c−1, ˜gt:t+c−1),\n5\nwhere the intermediate goals ˜gt+1:t+c−1 are computed using the ﬁxed goal transition functionh. In\neffect, each time we modify the low-level policyµlo, we would like to answer the question: for which\ngoals would this new controller have taken the same actions as the old one?\nMost RL algorithms will use random action-space exploration to select actions, which means that\nthe behavior policy (even for deterministic algorithms such as DDPG [25]) is stochastic and the log\nprobability logµlo(at:t+c−1|st:t+c−1, ˜gt:t+c−1) may be computed as\nlogµlo(at:t+c−1|st:t+c−1, ˜gt:t+c−1)∝− 1\n2\nt+c−1∑\ni=t\n||ai−µlo(si, ˜gi)||2\n2 + const. (5)\nTo approximately maximize this quantity in practice, we compute this log probability for a number of\ngoals ˜gt, and choose the maximal goal to re-label the experience. In our implementation, we calculate\nthe quantity on eight candidate goals sampled randomly from a Gaussian centered atst+c−st. We\nalso include the original goalgt and a goal corresponding to the differencest+c−st in the candidate\nset, to have a total of 10 candidates. This provides a suitably diverse set of ˜gt to approximately\nsolve the arg max of Equation 5, while also biasing the result to be closer to candidates ˜gt which\nwe believe to be appropriate given our knowledge of the problem (see additional implementation\ndetails in the Appendix). Our approach here is only an approximation, and we elaborate on possible\nalternative off-policy corrections in the Appendix.\n4 Related Work\nDiscovering meaningful and effective hierarchies of policies is a long standing research problem\nin RL [ 7, 29, 39, 8, 2]. Classically, the work on HRL focused on discrete state domains, where\nstate visitation and transition statistics can be used to construct heuristic sub-goals for low-level\npolicies [37, 27, 5]. The options framework [ 39, 32], a popular formulation for HRL, proposes a\ntermination policy for each sub-policy (option). While the traditional options framework relies on\nprior knowledge for designing options, [ 2] recently derived an actor-critic algorithm for learning\nthem jointly with the higher-level policy. This option-critic architecture [ 2] is an important step\ntoward end-to-end HRL; however, such approaches are often prone to learning either a sub-policy that\nterminates every time step, or one effective sub-policy that runs through the whole episode. In practice,\nregularizers are essential to learn multiple effective and temporally abstracted sub-policies [2, 16, 42].\nTo guarantee learning useful sub-policies, recent work has studied approaches that provide auxiliary\nrewards for the low-level policies [5, 18, 22, 40, 10]. These approaches rely on hand-crafted rewards\nbased on prior domain knowledge [ 21, 18, 22, 40] or diversity-encouraging rewards like mutual\ninformation [6, 10]. A number of works have suggested that semantically distinct behavior can be\ninduced by training on a set of diverse tasks, and have suggested pre-training the lower-level policy\non such tasks [18, 10], or training the multi-level hierarchical policy in a multi-task setup [11, 36].\nHowever, having access to a collection of suitably similar tasks is a luxury which is not always\navailable and may require hand-design. Our method uses a generic reward that is speciﬁed with\nrespect to the state space, and therefore avoids designing various rewards or multiple tasks.\nAnother difference from most HRL work [ 10, 11] is that we use off-policy learning, leading to\nsigniﬁcant improvements in sample efﬁciency. In end-to-end HRL, off-policy RL creates a non-\nstationary problem for the higher-level policy, since the lower-level is constantly changing. We are\naware of only one recent work which applies HRL in an off-policy setting [24]. As in our work, the\nauthors devise a hierarchical structure in which a lower-level policy is trained to reach observations\ndirected by a higher-level policy. The multiple layers of policies are trained jointly in an off-policy\nmanner, while ignoring the non-stationarity problem which we realize is a key issue for off-policy\nHRL. Accordingly, we derive and test an off-policy correction in the context of HRL, and empirically\nshow that this technique is crucial to successfully train hierarchical policies on complex tasks.\nOur work is related to FeUdal Networks (FuN) [43], originally inspired from feudal RL [7]. FuN\nalso makes use of goals and a parameterized lower-level reward. Unlike our method, FuN represents\nthe goals and computes the rewards in terms of a learned state representation. In our experiments,\nwe found this technique to under-perform compared to our approach, which uses the state in its raw\nform. We ﬁnd that this has a number of beneﬁts. For one, the lower-level policies can immediately\nbegin receiving intrinsic rewards for reaching goals even before the higher-level policy receives a\nmeaningful supervision signal from the task reward. Additionally, the representation is generic and\n6\nAnt Gather Ant Maze Ant Push Ant Fall\nHIRO 3.02±1.49 0.99±0.01 0.92±0.04 0.66±0.07\nFuN representation 0.03± 0.01 0.0± 0.0 0.0± 0.0 0.0± 0.0\nFuN transition PG 0.41± 0.06 0.0± 0.0 0.56± 0.39 0.01± 0.02\nFuN cos similarity 0.85± 1.17 0.16± 0.33 0.06± 0.17 0.07± 0.22\nFuN 0.01± 0.01 0.0± 0.0 0.0± 0.0 0.0± 0.0\nSNN4HRL 1.92± 0.52 0.0± 0.0 0.02± 0.01 0.0± 0.0\nVIME 1.42± 0.90 0.0± 0.0 0.02± 0.02 0.0± 0.0\nTable 1: Performance of the best policy obtained in 10M steps of training, averaged over 10 randomly\nseeded trials with standard error. Comparisons are to variants of FuN [ 43], SNN4HRL [10], and\nVIME [20]. Even after extensive hyper-parameter searches, we were unable to achieve competitive\nperformance from the baselines on any of our tasks. In the Appendix, we include the only competitive\nresult we could achieve – VIME on Ant Gather trained for a much longer amount of time.\nsimple to obtain. Goal-conditioned value functions [26, 38, 34, 1, 31] are actively explored outside\nthe context of HRL. Continued progress in this ﬁeld may be used to further improve HRL methods.\n5 Experiments\nIn our experiments, we compare HIRO method to prior techniques, and ablate the various components\nto understand their importance. Our experiments are conducted on a set of challenging environ-\nments that require a combination of locomotion and object manipulation. Visualizations of these\nenvironments are shown in Figure 1. See the Appendix for more details on each environment.\nAnt Gather. The ant gather task is a standard task introduced in [9]. A simulated ant must navigate to\ngather apples while avoiding bombs, which are randomly placed in the environment at the beginning\nof each episode. The ant receives a reward of 1 for each apple and a reward of−1 for each bomb.\nAnt Maze. For the ﬁrst difﬁcult navigation task we adapted the maze environment introduced in [9].\nIn this environment an ant must navigate to various locations in a ‘⊃’-shaped corridor. We increase\nthe default size of the maze so that the corridor is of width 8. In our evaluation, we assess the success\nrate of the policy when attempting to reach the end of the maze.\nAnt Push. In this task we introduce a movable block which the agent can interact with. A greedy\nagent would move forward, unknowingly pushing the movable block until it blocks its path to the\ntarget. To successfully reach the target, the ant must ﬁrst move to the left around the block and then\npush the block right, clearing the path towards the target location.\nAnt Fall. This task extends the navigation to three dimensions. The ant is placed on a raised platform,\nwith the target location directly in front of it but separated by a chasm which it cannot traverse by\nitself. Luckily, a movable block is provided on its right. To successfully reach the target, the ant must\nﬁrst walk to the right, push the block into the chasm, and then safely cross.\n5.1 Comparative Analysis\nThe primary comparisons to previous HRL methods are done with respect to FeUdal Networks\n(FuN) [43], stochastic neural networks for HRL (SNN4HRL) [10], and VIME [20] (see Table 1, and\nAppendix for more details). As these algorithms often come with problem-speciﬁc design choices,\nwe modify each for fairer comparisons. In terms of problem assumptions, our work is closest to\nthat of FuN which is applicable to any single task without speciﬁc sub-policy reward engineering.\nMLSH [11] is another promising recent work for HRL; however, since it relies on learning meaningful\nsub-policies through experiencing multiple, diverse, hand-designed tasks, we do not include explicit\ncomparisons. We leave exploring our method in the context of multi-task learning for future work.\nFeUdal Network (FuN). Unlike SNN4HRL or VIME, the ofﬁcial open-source code for FuN was not\navailable at the time of submission, and therefore we aimed to replicate key design choices of FuN\nfrom our algorithm implementation. FuN [43] primarily proposes four components: (1) transition\npolicy gradient, (2) directional cosine similarity rewards, (3) goals speciﬁed with respect to a learned\nrepresentation, and (4) dilated RNN. Since our tasks are low-dimensional and fully observed, we do\n7\nAnt Gather Ant Maze Ant Push Ant Fall\n0 2 4 6 8 10\n0.0\n0.5\n1.0\n1.5\n2.0\n2.5\n3.0\n0 2 4 6 8 10\n0.0\n0.2\n0.4\n0.6\n0.8\n1.0\n0 2 4 6 8 10\n0.0\n0.1\n0.2\n0.3\n0.4\n0.5\n0.6\n0 2 4 6 8 10\n0.0\n0.1\n0.2\n0.3\n0.4\n0.5\nHIRO\nWith lower-level re-labelling\nWith pre-training\nNo oﬀ-policy correction\nNo HRL\nFigure 4: Results of our method and a number of variants on a set of difﬁcult tasks. Each plot\nshows average reward (for Ant Gather) or average success rate (for the rest; see Appendix) over 10\nrandomly seeded trials, with x-axis in millions of environment steps. We ﬁnd that HIRO can perform\nwell across all tasks. We also note that HIRO learns rapidly; on the complex navigation tasks it\nrequires only a few million environment steps (a few days in real-world interaction time) to achieve\ngood performance. Our method is only out-performed on Ant Gather by a variant that pre-trains the\nlower-level policy (thus not needing an off-policy correction).\nnot include design choice (4). For each of (1), (2), and (3), we apply an equivalent modiﬁcation of\nour HRL method and evaluate its performance on the same tasks. We also evaluate all modiﬁcations\ntogether as an approximation to the entire FuN paradigm. Results in Table 1 show that on our tasks,\nthe FuN modiﬁcations do not learn well, and other than Ant Gather are signiﬁcantly out-performed by\nHIRO. In particular, it is worth noting that the use of learned representations, rather than observation\ngoals, leads to almost no improvement on the tasks. This suggests that the choice of using goal\nobservations as lower-level goals signiﬁcantly improves HRL performance, by providing a strong\nsupervision signal to the lower-level policy right from the beginning of training.\nStochastic Neural Networks for HRL (SNN4HRL). SNN4HRL [10] initially trains the low-level\npolicy with a proxy reward to encourage learning useful diverse exploration policies, and then the\nhigh-level policy is trained in the tasks of interest while the low-level is ﬁxed. While SNN4HRL can\nperform better than FuN, it is still far behind our proposed HRL method.\nVariational Information Maximizing Exploration (VIME). VIME [20] is not an HRL method but\nis used as a strong baseline in SNN4HRL. As discussed in [10] and matched by our results, for the\nbenchmark’s short horizon task of length 500, it performs approximately the same as SNN4HRL.\nOption-Critic Architecture. We extended the option-critic architecture implementation [ 2] for\ncontinuous actions and attempted a number of alternative variants besides the naïve modiﬁcation\nof the original. No versions yielded reasonable performance in our tasks, and so we omit it from\nthe results. This is possibly due to difﬁculty in continuous control tasks, but most importantly the\noption-critic sub-policies rely solely on the external reward, making learning gait policies difﬁcult.\n5.2 Ablative Analysis\nIn Figure 4 we present results of our proposed HRL method (“HIRO”) compared with a number of\nvariants to understand the importance of various design choices:\nWith lower-level re-labelling. We evaluate the beneﬁt of recent proposals [1, 23] to increase the\namount of data available to an agent trained using a parameterized reward (the lower-level policy\nin our setup) by re-labeling experiences with randomly sampled goals. This allows the lower-level\npolicy to use experience collected with respect to a speciﬁc goalg to be used to learn behavior with\nrespect to any alternative goal ˜g. Our results show that this technique can provide an initial speed-up\nin training; however, its performance is quick to plateau. We hypothesize that re-labeling goals\nrandomly may make lower-level training more difﬁcult, since the policy must learn to not only satisfy\nthe goals provided by the higher-level agent, but instead almost any conceivable goal. The beneﬁt of\nre-labeling goals will require more research, and we encourage future work to investigate better ways\nto harness its beneﬁts.\n8\nWith pre-training. In this variant we evaluate a simpler method to avoid the non-stationary issue\nin higher-level off-policy training. Rather than correct for past experiences, we instead pre-train\nthe lower-level policy for 2M steps (using goals sampled from a Gaussian) before freezing it and\ntraining the higher-level policy alone (this variant also has the advantage of allowing the higher-level\npolicy to learn with respect to a deterministic, non-exploratory lower-level policy). In the harder\nnavigation tasks, we ﬁnd that pre-training is detrimental. This is understandable, as these tasks require\nspecialization in different low-level behavior for different stages of the navigation. By allowing the\nlower-level policy to continually learn as new parts of the environment are encountered, we are able\nto learn a lower-level policy which is better able to satisfy the desired goals of the higher-level. In\ncontrast, in the simpler and mostly homogeneous Ant Gather task, the advantage of pre-training is\nsigniﬁcant. This suggests that our off-policy correction is still not perfect, and there is potentially\nsigniﬁcant beneﬁt to be obtained by improving it.\nNo off-policy correction. We assess the advantage of including the off-policy correction compared\nto training off-policy naïvely, ignoring the non-stationary issue. Interestingly, training an HRL policy\nthis way can do quite well. However, in the harder tasks (Ant Push, Ant Fall) the issue becomes\ndifﬁcult to ignore. Accordingly, we observe a signiﬁcant beneﬁt from using the off-policy correction.\nNo HRL. Finally, we evaluate the ability of a single non-HRL policy to learn in these environments.\nThis variant makes almost no progress on the tasks compared to our HRL method.\n6 Conclusion\nWe have presented a method for training a two-layer hierarchical policy. Our approach is general,\nusing learned goals to pass instructions from the higher-level policy to the lower-level one. Moreover,\nwe have described a method by which both polices may be trained in an off-policy manner concurrently\nfor highly sample-efﬁcient learning. Our experiments show that our method outperforms prior HRL\nalgorithms and can solve exceedingly complex tasks that combine locomotion and rudimentary object\ninteraction. We note that our results are still far from perfect, and there is much work left for future\nresearch to improve the stability and performance of HRL methods on these tasks.\n7 Acknowledgments\nWe thank Ben Eysenbach and others on the Google Brain team for insightful comments and discus-\nsions.\nReferences\n[1] Marcin Andrychowicz, Filip Wolski, Alex Ray, Jonas Schneider, Rachel Fong, Peter Welinder,\nBob McGrew, Josh Tobin, OpenAI Pieter Abbeel, and Wojciech Zaremba. Hindsight experience\nreplay. In Advances in Neural Information Processing Systems, pages 5048–5058, 2017.\n[2] Pierre-Luc Bacon, Jean Harb, and Doina Precup. The option-critic architecture. In AAAI, pages\n1726–1734, 2017.\n[3] Gabriel Barth-Maron, Matthew W Hoffman, David Budden, Will Dabney, Dan Horgan, Alistair\nMuldal, Nicolas Heess, and Timothy Lillicrap. Distributed distributional deterministic policy\ngradients. arXiv preprint arXiv:1804.08617, 2018.\n[4] Andrew G Barto and Sridhar Mahadevan. Recent advances in hierarchical reinforcement\nlearning. Discrete Event Dynamic Systems, 13(4):341–379, 2003.\n[5] Nuttapong Chentanez, Andrew G Barto, and Satinder P Singh. Intrinsically motivated rein-\nforcement learning. In Advances in neural information processing systems, pages 1281–1288,\n2005.\n[6] Christian Daniel, Gerhard Neumann, and Jan Peters. Hierarchical relative entropy policy search.\nIn Artiﬁcial Intelligence and Statistics, pages 273–281, 2012.\n[7] Peter Dayan and Geoffrey E Hinton. Feudal reinforcement learning. In Advances in neural\ninformation processing systems, pages 271–278, 1993.\n9\n[8] Thomas G Dietterich. Hierarchical reinforcement learning with the maxq value function\ndecomposition. Journal of Artiﬁcial Intelligence Research, 13:227–303, 2000.\n[9] Yan Duan, Xi Chen, Rein Houthooft, John Schulman, and Pieter Abbeel. Benchmarking\ndeep reinforcement learning for continuous control. In International Conference on Machine\nLearning, pages 1329–1338, 2016.\n[10] Carlos Florensa, Yan Duan, and Pieter Abbeel. Stochastic neural networks for hierarchical\nreinforcement learning. arXiv preprint arXiv:1704.03012, 2017.\n[11] Kevin Frans, Jonathan Ho, Xi Chen, Pieter Abbeel, and John Schulman. Meta learning shared\nhierarchies. International Conference on Learning Representations (ICLR), 2018.\n[12] Scott Fujimoto, Herke van Hoof, and Dave Meger. Addressing function approximation error in\nactor-critic methods. arXiv preprint arXiv:1802.09477, 2018.\n[13] Shixiang Gu, Ethan Holly, Timothy Lillicrap, and Sergey Levine. Deep reinforcement learning\nfor robotic manipulation with asynchronous off-policy updates. In Robotics and Automation\n(ICRA), 2017 IEEE International Conference on, pages 3389–3396. IEEE, 2017.\n[14] Shixiang Gu, Timothy Lillicrap, Zoubin Ghahramani, Richard E Turner, and Sergey\nLevine. Q-prop: Sample-efﬁcient policy gradient with an off-policy critic. arXiv preprint\narXiv:1611.02247, 2016.\n[15] Tuomas Haarnoja, Aurick Zhou, Pieter Abbeel, and Sergey Levine. Soft actor-critic: Off-\npolicy maximum entropy deep reinforcement learning with a stochastic actor. arXiv preprint\narXiv:1801.01290, 2018.\n[16] Jean Harb, Pierre-Luc Bacon, Martin Klissarov, and Doina Precup. When waiting is not an\noption: Learning options with a deliberation cost. arXiv preprint arXiv:1709.04571, 2017.\n[17] Nicolas Heess, Srinivasan Sriram, Jay Lemmon, Josh Merel, Greg Wayne, Yuval Tassa, Tom\nErez, Ziyu Wang, Ali Eslami, Martin Riedmiller, et al. Emergence of locomotion behaviours in\nrich environments. arXiv preprint arXiv:1707.02286, 2017.\n[18] Nicolas Heess, Greg Wayne, Yuval Tassa, Timothy Lillicrap, Martin Riedmiller, and David Sil-\nver. Learning and transfer of modulated locomotor controllers.arXiv preprint arXiv:1610.05182,\n2016.\n[19] David Held, Xinyang Geng, Carlos Florensa, and Pieter Abbeel. Automatic goal generation for\nreinforcement learning agents. arXiv preprint arXiv:1705.06366, 2017.\n[20] Rein Houthooft, Xi Chen, Yan Duan, John Schulman, Filip De Turck, and Pieter Abbeel. Vime:\nVariational information maximizing exploration. In Advances in Neural Information Processing\nSystems, pages 1109–1117, 2016.\n[21] George Konidaris and Andrew G Barto. Building portable options: Skill transfer in reinforce-\nment learning. In IJCAI, volume 7, pages 895–900, 2007.\n[22] Tejas D Kulkarni, Karthik Narasimhan, Ardavan Saeedi, and Josh Tenenbaum. Hierarchical\ndeep reinforcement learning: Integrating temporal abstraction and intrinsic motivation. In\nAdvances in neural information processing systems, pages 3675–3683, 2016.\n[23] Sergey Levine, Shane Gu, and Vitchyr Pong. Temporal difference model learning: Model-free\ndeep rl for model-based control. 2018.\n[24] Andrew Levy, Robert Platt, and Kate Saenko. Hierarchical actor-critic. arXiv preprint\narXiv:1712.00948, 2017.\n[25] Timothy P Lillicrap, Jonathan J Hunt, Alexander Pritzel, Nicolas Heess, Tom Erez, Yuval Tassa,\nDavid Silver, and Daan Wierstra. Continuous control with deep reinforcement learning. arXiv\npreprint arXiv:1509.02971, 2015.\n[26] Sridhar Mahadevan and Mauro Maggioni. Proto-value functions: A laplacian framework for\nlearning representation and control in markov decision processes. Journal of Machine Learning\nResearch, 8(Oct):2169–2231, 2007.\n[27] Shie Mannor, Ishai Menache, Amit Hoze, and Uri Klein. Dynamic abstraction in reinforcement\nlearning via clustering. In Proceedings of the twenty-ﬁrst international conference on Machine\nlearning, page 71. ACM, 2004.\n[28] Oﬁr Nachum, Mohammad Norouzi, Kelvin Xu, and Dale Schuurmans. Trust-pcl: An off-policy\ntrust region method for continuous control. arXiv preprint arXiv:1707.01891, 2017.\n10\n[29] Ronald Parr and Stuart J Russell. Reinforcement learning with hierarchies of machines. In\nAdvances in neural information processing systems, pages 1043–1049, 1998.\n[30] Matthias Plappert, Marcin Andrychowicz, Alex Ray, Bob McGrew, Bowen Baker, Glenn\nPowell, Jonas Schneider, Josh Tobin, Maciek Chociej, Peter Welinder, et al. Multi-goal\nreinforcement learning: Challenging robotics environments and request for research. arXiv\npreprint arXiv:1802.09464, 2018.\n[31] Vitchyr Pong, Shixiang Gu, Murtaza Dalal, and Sergey Levine. Temporal difference models:\nModel-free deep rl for model-based control. International Conference on Learning Representa-\ntions, 2018.\n[32] Doina Precup. Temporal abstraction in reinforcement learning. University of Massachusetts\nAmherst, 2000.\n[33] Aravind Rajeswaran, Vikash Kumar, Abhishek Gupta, John Schulman, Emanuel Todorov, and\nSergey Levine. Learning complex dexterous manipulation with deep reinforcement learning\nand demonstrations. arXiv preprint arXiv:1709.10087, 2017.\n[34] Tom Schaul, Daniel Horgan, Karol Gregor, and David Silver. Universal value function approxi-\nmators. In International Conference on Machine Learning, pages 1312–1320, 2015.\n[35] John Schulman, Sergey Levine, Pieter Abbeel, Michael Jordan, and Philipp Moritz. Trust region\npolicy optimization. In International Conference on Machine Learning , pages 1889–1897,\n2015.\n[36] Olivier Sigaud and Freek Stulp. Policy search in continuous action domains: an overview. arXiv\npreprint arXiv:1803.04706, 2018.\n[37] Martin Stolle and Doina Precup. Learning options in reinforcement learning. In International\nSymposium on abstraction, reformulation, and approximation, pages 212–223. Springer, 2002.\n[38] Richard S Sutton, Joseph Modayil, Michael Delp, Thomas Degris, Patrick M Pilarski, Adam\nWhite, and Doina Precup. Horde: A scalable real-time architecture for learning knowledge\nfrom unsupervised sensorimotor interaction. In The 10th International Conference on Au-\ntonomous Agents and Multiagent Systems-Volume 2, pages 761–768. International Foundation\nfor Autonomous Agents and Multiagent Systems, 2011.\n[39] Richard S Sutton, Doina Precup, and Satinder Singh. Between mdps and semi-mdps: A\nframework for temporal abstraction in reinforcement learning. Artiﬁcial intelligence, 112(1-\n2):181–211, 1999.\n[40] Chen Tessler, Shahar Givony, Tom Zahavy, Daniel J Mankowitz, and Shie Mannor. A deep\nhierarchical approach to lifelong learning in minecraft. In AAAI, volume 3, page 6, 2017.\n[41] Matej Veˇcerík, Todd Hester, Jonathan Scholz, Fumin Wang, Olivier Pietquin, Bilal Piot, Nicolas\nHeess, Thomas Rothörl, Thomas Lampe, and Martin Riedmiller. Leveraging demonstrations\nfor deep reinforcement learning on robotics problems with sparse rewards. arXiv preprint\narXiv:1707.08817, 2017.\n[42] Alexander Vezhnevets, V olodymyr Mnih, Simon Osindero, Alex Graves, Oriol Vinyals, John\nAgapiou, et al. Strategic attentive writer for learning macro-actions. In Advances in neural\ninformation processing systems, pages 3486–3494, 2016.\n[43] Alexander Sasha Vezhnevets, Simon Osindero, Tom Schaul, Nicolas Heess, Max Jaderberg,\nDavid Silver, and Koray Kavukcuoglu. Feudal networks for hierarchical reinforcement learning.\narXiv preprint arXiv:1703.01161, 2017.\n11",
  "values": {
    "Interpretable (to users)": "Yes",
    "Non-maleficence": "Yes",
    "Critiqability": "Yes",
    "Respect for Law and public interest": "Yes",
    "Transparent (to users)": "Yes",
    "Explicability": "Yes",
    "Privacy": "Yes",
    "Respect for Persons": "Yes",
    "Beneficence": "Yes",
    "User influence": "Yes",
    "Collective influence": "Yes",
    "Autonomy (power to decide)": "Yes",
    "Fairness": "Yes",
    "Not socially biased": "Yes",
    "Justice": "Yes",
    "Deferral to humans": "Yes"
  }
}