{
  "pdf": "NeurIPS-2018-glow-generative-flow-with-invertible-1x1-convolutions-Paper",
  "title": "Glow: Generative Flow with Invertible 1x1 Convolutions",
  "author": "Durk P. Kingma, Prafulla Dhariwal",
  "paper_id": "NeurIPS-2018-glow-generative-flow-with-invertible-1x1-convolutions-Paper",
  "text": "Glow: Generative Flow\nwith Invertible 1×1 Convolutions\nDiederik P. Kingma*†, Prafulla Dhariwal∗\n*OpenAI\n†Google AI\nAbstract\nFlow-based generative models (Dinh et al., 2014) are conceptually attractive due to\ntractability of the exact log-likelihood, tractability of exact latent-variable inference,\nand parallelizability of both training and synthesis. In this paper we propose Glow,\na simple type of generative ﬂow using an invertible 1 × 1 convolution. Using our\nmethod we demonstrate a signiﬁcant improvement in log-likelihood on standard\nbenchmarks. Perhaps most strikingly, we demonstrate that a ﬂow-based generative\nmodel optimized towards the plain log-likelihood objective is capable of efﬁcient\nrealistic-looking synthesis and manipulation of large images. The code for our\nmodel is available at https://github.com/openai/glow.\n1 Introduction\nTwo major unsolved problems in the ﬁeld of machine learning are (1) data-efﬁciency: the ability to\nlearn from few datapoints, like humans; and (2) generalization: robustness to changes of the task or\nits context. AI systems, for example, often do not work at all when given inputs that are different\n∗Equal contribution.\n32nd Conference on Neural Information Processing Systems (NeurIPS 2018), Montréal, Canada.\nFigure 1: Synthetic celebrities sampled from our model; see Section 3 for architecture and method,\nand Section 5 for more results.\nfrom their training distribution. A promise of generative models, a major branch of machine learning,\nis to overcome these limitations by: (1) learning realistic world models, potentially allowing agents to\nplan in a world model before actual interaction with the world, and (2) learning meaningful features\nof the input while requiring little or no human supervision or labeling. Since such features can be\nlearned from large unlabeled datasets and are not necessarily task-speciﬁc, downstream solutions\nbased on those features could potentially be more robust and more data efﬁcient. In this paper we\nwork towards this ultimate vision, in addition to intermediate applications, by aiming to improve\nupon the state-of-the-art of generative models.\nGenerative modeling is generally concerned with the extremely challenging task of modeling all\ndependencies within very high-dimensional input data, usually speciﬁed in the form of a full joint\nprobability distribution. Since such joint models potentially capture all patterns that are present in the\ndata, the applications of accurate generative models are near endless. Immediate applications are as\ndiverse as speech synthesis, text analysis, semi-supervised learning and model-based control; see\nSection 4 for references.\nThe discipline of generative modeling has experienced enormous leaps in capabilities in recent years,\nmostly with likelihood-based methods (Graves, 2013; Kingma and Welling, 2013, 2018; Dinh et al.,\n2014; van den Oord et al., 2016a) and generative adversarial networks (GANs) (Goodfellow et al.,\n2014) (see Section 4). Likelihood-based methods can be divided into three categories:\n1. Autoregressive models (Hochreiter and Schmidhuber, 1997; Graves, 2013; van den Oord\net al., 2016a,b; Van Den Oord et al., 2016). Those have the advantage of simplicity, but have\nas disadvantage that synthesis has limited parallelizability, since the computational length of\nsynthesis is proportional to the dimensionality of the data; this is especially troublesome for\nlarge images or video.\n2. Variational autoencoders (V AEs) (Kingma and Welling, 2013, 2018), which optimize a\nlower bound on the log-likelihood of the data. Variational autoencoders have the advantage\nof parallelizability of training and synthesis, but can be comparatively challenging to\noptimize (Kingma et al., 2016).\n3. Flow-based generative models, ﬁrst described in NICE (Dinh et al., 2014) and extended in\nRealNVP (Dinh et al., 2016). We explain the key ideas behind this class of model in the\nfollowing sections.\nFlow-based generative models have so far gained little attention in the research community compared\nto GANs (Goodfellow et al., 2014) and V AEs (Kingma and Welling, 2013). Some of the merits of\nﬂow-based generative models include:\n• Exact latent-variable inference and log-likelihood evaluation. In V AEs, one is able to infer\nonly approximately the value of the latent variables that correspond to a datapoint. GAN’s\nhave no encoder at all to infer the latents. In reversible generative models, this can be done\nexactly without approximation. Not only does this lead to accurate inference, it also enables\noptimization of the exact log-likelihood of the data, instead of a lower bound of it.\n• Efﬁcient inference and efﬁcient synthesis. Autoregressive models, such as the Pixel-\nCNN (van den Oord et al., 2016b), are also reversible, however synthesis from such models\nis difﬁcult to parallelize, and typically inefﬁcient on parallel hardware. Flow-based gener-\native models like Glow (and RealNVP) are efﬁcient to parallelize for both inference and\nsynthesis.\n• Useful latent space for downstream tasks. The hidden layers of autoregressive models\nhave unknown marginal distributions, making it much more difﬁcult to perform valid\nmanipulation of data. In GANs, datapoints can usually not be directly represented in a latent\nspace, as they have no encoder and might not have full support over the data distribution.\n(Grover et al., 2018). This is not the case for reversible generative models and V AEs, which\nallow for various applications such as interpolations between datapoints and meaningful\nmodiﬁcations of existing datapoints.\n• Signiﬁcant potential for memory savings. Computing gradients in reversible neural networks\nrequires an amount of memory that is constant instead of linear in their depth, as explained\nin the RevNet paper (Gomez et al., 2017).\n2\nIn this paper we propose a new a generative ﬂow coinedGlow, with various new elements as described\nin Section 3. In Section 5, we compare our model quantitatively with previous ﬂows, and in Section\n6, we study the qualitative aspects of our model on high-resolution datasets.\n2 Background: Flow-based Generative Models\nLet x be a high-dimensional random vector with unknown true distribution x ∼p∗(x). We collect\nan i.i.d. dataset D, and choose a model pθ(x) with parameters θ. In case of discrete data x, the\nlog-likelihood objective is then equivalent to minimizing:\nL(D) = 1\nN\nN∑\ni=1\n− logpθ(x(i)) (1)\nIn case of continuous data x, we minimize the following:\nL(D) ≃ 1\nN\nN∑\ni=1\n− logpθ(˜x(i)) +c (2)\nwhere ˜x(i) = x(i) +u with u ∼ U (0,a ), and c = −M · loga where a is determined by the\ndiscretization level of the data andM is the dimensionality of x. Both objectives (eqs. (1) and (2))\nmeasure the expected compression cost in nats or bits; see (Dinh et al., 2016). Optimization is done\nthrough stochastic gradient descent using minibatches of data (Kingma and Ba, 2015).\nIn most ﬂow-based generative models (Dinh et al., 2014, 2016), the generative process is deﬁned as:\nz ∼pθ(z) (3)\nx = gθ(z) (4)\nwhere z is the latent variable andpθ(z) has a (typically simple) tractable density, such as a spherical\nmultivariate Gaussian distribution:pθ(z) = N (z; 0, I). The function gθ(..) is invertible, also called\nbijective, such that given a datapoint x, latent-variable inference is done by z = fθ(x) = g−1\nθ (x).\nFor brevity, we will omit subscript θ from fθ and gθ.\nWe focus on functions where f (and, likewise, g) is composed of a sequence of transformations:\nf = f1 ◦ f2 ◦ · · · ◦ fK, such that the relationship between x and z can be written as:\nx\nf1\n← →h1\nf2\n← →h2 · · ·\nfK\n← →z (5)\nSuch a sequence of invertible transformations is also called a (normalizing) ﬂow (Rezende and\nMohamed, 2015). Under the change of variables of eq. (4), the probability density function (pdf) of\nthe model given a datapoint can be written as:\nlogpθ(x) = log pθ(z) + log | det(dz/dx)| (6)\n= logpθ(z) +\nK∑\ni=1\nlog | det(dhi/dhi−1)| (7)\nwhere we deﬁne h0 ≜ x and hK ≜ z for conciseness. The scalar value log | det(dhi/dhi−1)| is\nthe logarithm of the absolute value of the determinant of the Jacobian matrix (dhi/dhi−1), also\ncalled the log-determinant. This value is the change in log-density when going from hi−1 to hi\nunder transformation fi. While it may look intimidating, its value can be surprisingly simple to\ncompute for certain choices of transformations, as previously explored in (Deco and Brauer, 1995;\nDinh et al., 2014; Rezende and Mohamed, 2015; Kingma et al., 2016). The basic idea is to choose\ntransformations whose Jacobiandhi/dhi−1 is a triangular matrix. For those transformations, the\nlog-determinant is simple:\nlog | det(dhi/dhi−1)| = sum(log |diag(dhi/dhi−1)|) (8)\nwhere sum() takes the sum over all vector elements, log() takes the element-wise logarithm, and\ndiag() takes the diagonal of the Jacobian matrix.\n3\nsqueeze\nstep of ﬂow\nsplit\n× K × (L−1) \nsqueeze\nstep of ﬂow× K \nx\nzi\nzL\nsqueeze\nactnorm\nsplit\n× K × (L−1) \nsqueeze\nstep of ﬂow× K \nx\nzl\nzL\ninvertible 1x1 conv\naﬃne coupling layer\nactnorm\ninvertible 1x1 conv\naﬃne coupling layer\n(a) One step of our ﬂow.\nsqueeze\nstep of ﬂow\nsplit\n× K × (L−1) \nsqueeze\nstep of ﬂow× K \nx\nzi\nzL\nsqueeze\nactnorm\nsplit\n× K × (L−1) \nsqueeze\nstep of ﬂow× K \nx\nzl\nzL\ninvertible 1x1 conv\naﬃne coupling layer\nactnorm\ninvertible 1x1 conv\naﬃne coupling layer (b) Multi-scale architecture (Dinh et al., 2016).\nFigure 2: We propose a generative ﬂow where each step (left) consists of an actnorm step, followed\nby an invertible 1 × 1 convolution, followed by an afﬁne transformation (Dinh et al., 2014). This\nﬂow is combined with a multi-scale architecture (right). See Section 3 and Table 1.\nTable 1: The three main components of our proposed ﬂow, their reverses, and their log-determinants.\nHere, x signiﬁes the input of the layer, and y signiﬁes its output. Both x and y are tensors of\nshape [h ×w ×c] with spatial dimensions (h,w ) and channel dimensionc. With (i,j ) we denote\nspatial indices into tensors x and y. The function NN() is a nonlinear mapping, such as a (shallow)\nconvolutional neural network like in ResNets (He et al., 2016) and RealNVP (Dinh et al., 2016).\nDescription Function Reverse Function Log-determinant\nActnorm.\nSee Section 3.1.\n∀i, j : yi,j = s⊙ xi,j + b ∀i, j : xi,j = (yi,j− b)/s h· w· sum(log|s|)\nInvertible 1× 1 convolution.\nW : [c× c].\nSee Section 3.2.\n∀i, j : yi,j = Wxi,j ∀i, j : xi,j = W−1yi,j h· w· log| det(W)|\nor\nh· w· sum(log|s|)\n(see eq. (10))\nAfﬁne coupling layer.\nSee Section 3.3 and\n(Dinh et al., 2014)\nxa, xb = split(x)\n(log s, t) = NN(xb)\ns = exp(log s)\nya = s⊙ xa + t\nyb = xb\ny = concat(ya, yb)\nya, yb = split(y)\n(log s, t) = NN(yb)\ns = exp(log s)\nxa = (ya− t)/s\nxb = yb\nx = concat(xa, xb)\nsum(log(|s|))\n3 Proposed Generative Flow\nWe propose a new ﬂow, building on the NICE and RealNVP ﬂows proposed in (Dinh et al., 2014,\n2016). It consists of a series of steps of ﬂow, combined in a multi-scale architecture; see Figure 2.\nEach step of ﬂow consists of actnorm (Section 3.1) followed by an invertible 1 × 1 convolution\n(Section 3.2), followed by a coupling layer (Section 3.3).\nThis ﬂow is combined with a multi-scale architecture; due to space constraints we refer to (Dinh et al.,\n2016) for more details. This architecture has a depth of ﬂow K, and number of levelsL (Figure 2).\n3.1 Actnorm: scale and bias layer with data dependent initialization\nIn Dinh et al. (2016), the authors propose the use of batch normalization (Ioffe and Szegedy, 2015)\nto alleviate the problems encountered when training deep models. However, since the variance of\n4\nactivations noise added by batch normalization is inversely proportional to minibatch size per GPU\nor other processing unit (PU), performance is known to degrade for small per-PU minibatch size.\nFor large images, due to memory constraints, we learn with minibatch size 1 per PU. We propose an\nactnorm layer (for activation normalizaton), that performs an afﬁne transformation of the activations\nusing a scale and bias parameter per channel, similar to batch normalization. These parameters are\ninitialized such that the post-actnorm activations per-channel have zero mean and unit variance given\nan initial minibatch of data. This is a form of data dependent initialization (Salimans and Kingma,\n2016). After initialization, the scale and bias are treated as regular trainable parameters that are\nindependent of the data.\n3.2 Invertible 1 × 1 convolution\n(Dinh et al., 2014, 2016) proposed a ﬂow containing the equivalent of a permutation that reverses the\nordering of the channels. We propose to replace this ﬁxed permutation with a (learned) invertible\n1 × 1 convolution, where the weight matrix is initialized as a random rotation matrix. Note that a\n1 × 1 convolution with equal number of input and output channels is a generalization of a permutation\noperation.\nThe log-determinant of an invertible 1 × 1 convolution of ah ×w ×c tensor h withc ×c weight\nmatrix W is straightforward to compute:\nlog\n⏐⏐⏐⏐det\n(d conv2D(h; W)\nd h\n)⏐⏐⏐⏐ =h ·w · log | det(W)| (9)\nThe cost of computing or differentiating det(W) is O(c3), which is often comparable to the cost\ncomputing conv2D(h; W) which is O(h ·w ·c2). We initialize the weights W as a random rotation\nmatrix, having a log-determinant of 0; after one SGD step these values start to diverge from 0.\nLU Decomposition. This cost of computing det(W) can be reduced from O(c3) to O(c) by\nparameterizing W directly in its LU decomposition:\nW = PL(U + diag(s)) (10)\nwhere P is a permutation matrix, L is a lower triangular matrix with ones on the diagonal, U is an\nupper triangular matrix with zeros on the diagonal, and s is a vector. The log-determinant is then\nsimply:\nlog | det(W)| = sum(log |s|) (11)\nThe difference in computational cost will become signiﬁcant for largec, although for the networks in\nour experiments we did not measure a large difference in wallclock computation time.\nIn this parameterization, we initialize the parameters by ﬁrst sampling a random rotation matrixW,\nthen computing the corresponding value of P (which remains ﬁxed) and the corresponding initial\nvalues of L and U and s (which are optimized).\n3.3 Afﬁne Coupling Layers\nA powerful reversible transformation where the forward function, the reverse function and the log-\ndeterminant are computationally efﬁcient, is theafﬁne coupling layer introduced in (Dinh et al., 2014,\n2016). See Table 1. An additive coupling layer is a special case with s = 1 and a log-determinant of\n0.\nZero initialization. We initialize the last convolution of eachNN() with zeros, such that each afﬁne\ncoupling layer initially performs an identity function; we found that this helps training very deep\nnetworks.\nSplit and concatenation. As in (Dinh et al., 2014), the split() function splits h the input tensor\ninto two halves along the channel dimension, while the concat() operation performs the correspond-\ning reverse operation: concatenation into a single tensor. In (Dinh et al., 2016), another type of split\nwas introduced: along the spatial dimensions using a checkerboard pattern. In this work we only\nperform splits along the channel dimension, simplifying the overall architecture.\n5\nPermutation. Each step of ﬂow above should be preceded by some kind of permutation of the\nvariables that ensures that after sufﬁcient steps of ﬂow, each dimensions can affect every other\ndimension. The type of permutation speciﬁcally done in (Dinh et al., 2014, 2016) is equivalent to\nsimply reversing the ordering of the channels (features) before performing an additive coupling\nlayer. An alternative is to perform a (ﬁxed) random permutation. Our invertible 1x1 convolution is a\ngeneralization of such permutations. In experiments we compare these three choices.\n4 Related Work\nThis work builds upon the ideas and ﬂows proposed in (Dinh et al., 2014) (NICE) and (Dinh et al.,\n2016) (RealNVP); comparisons with this work are made throughout this paper. In (Papamakarios\net al., 2017) (MAF), the authors propose a generative ﬂow based on IAF (Kingma et al., 2016);\nhowever, since synthesis from MAF is non-parallelizable and therefore inefﬁcient, we omit it from\ncomparisons. Synthesis from autoregressive (AR) models (Hochreiter and Schmidhuber, 1997;\nGraves, 2013; van den Oord et al., 2016a,b; Van Den Oord et al., 2016) is similarly non-parallelizable.\nSynthesis of high-dimensional data typically takes multiple orders of magnitude longer with AR\nmodels; see (Kingma et al., 2016; Oord et al., 2017) for evidence. Sampling 256 × 256 images with\nour largest models takes less than one second on current hardware. 2 (Reed et al., 2017) explores\ntechniques for speeding up synthesis in AR models considerably; we leave the comparison to this\nline of work to future work.\nGANs (Goodfellow et al., 2014) are arguably best known for their ability to synthesize large and\nrealistic images (Karras et al., 2017), in contrast with likelihood-based methods. Downsides of\nGANs are their general lack of latent-space encoders, their general lack of full support over the\ndata (Grover et al., 2018), their difﬁculty of optimization, and their difﬁculty of assessing overﬁtting\nand generalization.\n5 Quantitative Experiments\nWe begin our experiments by comparing how our new ﬂow compares against RealNVP (Dinh et al.,\n2016). We then apply our model on other standard datasets and compare log-likelihoods against\nprevious generative models. See the appendix for optimization details. In our experiments, we\nlet each NN() have three convolutional layers, where the two hidden layers have ReLU activation\nfunctions and 512 channels. The ﬁrst and last convolutions are3 × 3, while the center convolution is\n1 × 1, since both its input and output have a large number of channels, in contrast with the ﬁrst and\nlast convolution.\nGains using invertible 1 × 1 Convolution. We choose the architecture described in Section 3,\nand consider three variations for the permutation of the channel variables - a reversing operation\nas described in the RealNVP, a ﬁxed random permutation, and our invertible 1 × 1 convolution.\nWe compare for models with only additive coupling layers, and models with afﬁne coupling. As\ndescribed earlier, we initialize all models with a data-dependent initialization which normalizes the\nactivations of each layer. All models were trained withK = 32 andL = 3. The model with 1 × 1\nconvolution has a negligible 0.2% larger amount of parameters.\nWe compare the average negative log-likelihood (bits per dimension) on the CIFAR-10 (Krizhevsky,\n2009) dataset, keeping all training conditions constant and averaging across three random seeds.\nThe results are in Figure 3. As we see, for both additive and afﬁne couplings, the invertible 1 × 1\nconvolution achieves a lower negative log likelihood and converges faster. The afﬁne coupling models\nalso converge faster than the additive coupling models. We noted that the increase in wallclock time\nfor the invertible 1 × 1 convolution model was only ≈ 7%, thus the operation is computationally\nefﬁcient as well.\nComparison with RealNVP on standard benchmarks. Besides the permutation operation, the\nRealNVP architecture has other differences such as the spatial coupling layers. In order to verify\nthat our proposed architecture is overall competitive with the RealNVP architecture, we compare\n2More speciﬁcally, generating a256 × 256 image at batch size 1 takes about 130ms on a single NVIDIA\nGTX 1080 Ti, and about 550ms on a NVIDIA Tesla K80.\n6\n0 200 400 600 800 1000 1200 1400 1600 1800\nEpochs\n3.30\n3.35\n3.40\n3.45\n3.50\n3.55\n3.60\n3.65\n3.70NLL\nReverse\nShuffle\n1x1 Conv\n(a) Additive coupling.\n0 200 400 600 800 1000 1200 1400 1600 1800\nEpochs\n3.30\n3.35\n3.40\n3.45\n3.50\n3.55\n3.60\n3.65\n3.70NLL\nReverse\nShuffle\n1x1 Conv (b) Afﬁne coupling.\nFigure 3: Comparison of the three variants - a reversing operation as described in the RealNVP, a\nﬁxed random permutation, and our proposed invertible1 × 1 convolution, with additive (left) versus\nafﬁne (right) coupling layers. We plot the mean and standard deviation across three runs with different\nrandom seeds.\nTable 2: Best results in bits per dimension of our model compared to RealNVP.\nModel CIFAR-10ImageNet 32x32ImageNet 64x64LSUN (bedroom)LSUN (tower)LSUN (church outdoor)\nRealNVP3.49 4.28 3.98 2.72 2.81 3.08\nGlow 3.35 4.09 3.81 2.38 2.46 2.67\nour models on various natural images datasets. In particular, we compare on CIFAR-10, ImageNet\n(Russakovsky et al., 2015) and LSUN (Yu et al., 2015) datasets. We follow the same preprocessing\nas in (Dinh et al., 2016). For Imagenet, we use the 32 × 32 and 64 × 64 downsampled version of\nImageNet (Oord et al., 2016), and for LSUN we downsample to 96 × 96 and take random crops of\n64 × 64. We also include the bits/dimension for our model trained on 256 × 256 CelebA HQ used in\nour qualitative experiments.3 As we see in Table 2, our model achieves a signiﬁcant improvement on\nall the datasets.\n6 Qualitative Experiments\nWe now study the qualitative aspects of the model on high-resolution datasets. We choose the\nCelebA-HQ dataset (Karras et al., 2017), which consists of 30000 high resolution images from the\nCelebA dataset, and train the same architecture as above but now for images at a resolution of 2562,\nK = 32 andL = 6. To improve visual quality at the cost of slight decrease in color ﬁdelity, we train\nour models on 5-bit images. We aim to study if our model can scale to high resolutions, produce\nrealistic samples, and produce a meaningful latent space. Due to device memory constraints, at these\nresolutions we work with minibatch size 1 per PU, and use gradient checkpointing (Salimans and\nBulatov, 2017). In the future, we could use a constant amount of memory independent of depth by\nutilizing the reversibility of the model (Gomez et al., 2017).\nConsistent with earlier work on likelihood-based generative models, we found that sampling from\na reduced-temperature model (Parmar et al., 2018) often results in higher-quality samples. When\nsampling with temperature T , we sample from the distribution pθ,T (x) ∝ (pθ(x))T 2\n. In case of\nadditive coupling layers, this can be achieved simply by multiplying the standard deviation ofpθ(z)\nby a factor ofT .\nSynthesis and Interpolation. Figure 4 shows the random samples obtained from our model. The\nimages are of high quality for a non-autoregressive likelihood based model. To see how well we can\ninterpolate, we take a pair of real images, encode them with the encoder, and linearly interpolate\n3Since the original CelebA HQ dataset didn’t have a validation set, we separated it into a training set of\n27000 images and a validation set of 3000 images.\n7\nFigure 4: Random samples from the model, with temperature 0.7.\nFigure 5: Linear interpolation in latent space between real images.\nbetween the latents to obtain samples. The results in Figure 5 show that the image manifold of the\ngenerator distribution is smooth and almost all intermediate samples look like realistic faces.\nSemantic Manipulation. We now consider modifying attributes of an image. To do so, we use the\nlabels in the CelebA dataset. Each image has a binary label corresponding to presence or absence of\nattributes like smiling, blond hair, young, etc. This gives us 30000 binary labels for each attribute.\nWe then calculate the average latent vector zpos for images with the attribute and zneg for images\nwithout, and then use the difference (zpos − zneg) as a direction for manipulating. Note that this is a\nrelatively small amount of supervision, and is done after the model is trained (no labels were used\nwhile training), making it extremely easy to do for a variety of different target attributes. The results\nare shown in Figure 6 (appendix).\nEffect of temperature and model depth. Figure 8 (appendix) shows how the sample quality and\ndiversity varies with temperature. The highest temperatures have noisy images, possibly due to\noverestimating the entropy of the data distribution; we choose a temperature of 0.7 as a sweet spot\nfor diversity and quality of samples. Figure 9 (appendix) shows how model depth affects the ability\nof the model to learn long-range dependencies.\n7 Conclusion\nWe propose a new type of generative ﬂow and demonstrate improved quantitative performance in\nterms of log-likelihood on standard image modeling benchmarks. In addition, we demonstrate that\nwhen trained on high-resolution faces, our model is able to synthesize realistic images.\nReferences\nDeco, G. and Brauer, W. (1995). Higher order statistical decorrelation without information loss.\nAdvances in Neural Information Processing Systems, pages 247–254.\n3For 128 × 128 and 96 × 96 versions, we centre cropped the original image, and downsampled. For 64 × 64\nversion, we took random crops from the 96 × 96 downsampled image as done in Dinh et al. (2016)\n8\nDinh, L., Krueger, D., and Bengio, Y . (2014). Nice: non-linear independent components estimation.\narXiv preprint arXiv:1410.8516.\nDinh, L., Sohl-Dickstein, J., and Bengio, S. (2016). Density estimation using Real NVP. arXiv\npreprint arXiv:1605.08803.\nGomez, A. N., Ren, M., Urtasun, R., and Grosse, R. B. (2017). The reversible residual network:\nBackpropagation without storing activations. In Advances in Neural Information Processing\nSystems, pages 2211–2221.\nGoodfellow, I., Pouget-Abadie, J., Mirza, M., Xu, B., Warde-Farley, D., Ozair, S., Courville, A., and\nBengio, Y . (2014). Generative adversarial nets. In Advances in Neural Information Processing\nSystems, pages 2672–2680.\nGraves, A. (2013). Generating sequences with recurrent neural networks. arXiv preprint\narXiv:1308.0850.\nGrover, A., Dhar, M., and Ermon, S. (2018). Flow-gan: Combining maximum likelihood and\nadversarial learning in generative models. In AAAI Conference on Artiﬁcial Intelligence.\nHe, K., Zhang, X., Ren, S., and Sun, J. (2016). Identity mappings in deep residual networks. arXiv\npreprint arXiv:1603.05027.\nHochreiter, S. and Schmidhuber, J. (1997). Long Short-Term Memory. Neural computation ,\n9(8):1735–1780.\nIoffe, S. and Szegedy, C. (2015). Batch normalization: Accelerating deep network training by\nreducing internal covariate shift. arXiv preprint arXiv:1502.03167.\nKarras, T., Aila, T., Laine, S., and Lehtinen, J. (2017). Progressive growing of gans for improved\nquality, stability, and variation. arXiv preprint arXiv:1710.10196.\nKingma, D. and Ba, J. (2015). Adam: A method for stochastic optimization. Proceedings of the\nInternational Conference on Learning Representations 2015.\nKingma, D. P., Salimans, T., Jozefowicz, R., Chen, X., Sutskever, I., and Welling, M. (2016).\nImproved variational inference with inverse autoregressive ﬂow. InAdvances in Neural Information\nProcessing Systems, pages 4743–4751.\nKingma, D. P. and Welling, M. (2013). Auto-encoding variational Bayes. Proceedings of the 2nd\nInternational Conference on Learning Representations.\nKingma, D. P. and Welling, M. (2018). Variational autoencoders. Under Review.\nKrizhevsky, A. (2009). Learning multiple layers of features from tiny images.\nOord, A. v. d., Kalchbrenner, N., and Kavukcuoglu, K. (2016). Pixel recurrent neural networks.arXiv\npreprint arXiv:1601.06759.\nOord, A. v. d., Li, Y ., Babuschkin, I., Simonyan, K., Vinyals, O., Kavukcuoglu, K., Driessche, G.\nv. d., Lockhart, E., Cobo, L. C., Stimberg, F., et al. (2017). Parallel wavenet: Fast high-ﬁdelity\nspeech synthesis. arXiv preprint arXiv:1711.10433.\nPapamakarios, G., Murray, I., and Pavlakou, T. (2017). Masked autoregressive ﬂow for density\nestimation. In Advances in Neural Information Processing Systems, pages 2335–2344.\nParmar, N., Vaswani, A., Uszkoreit, J., Kaiser, Ł., Shazeer, N., and Ku, A. (2018). Image transformer.\narXiv preprint arXiv:1802.05751.\nReed, S., Oord, A. v. d., Kalchbrenner, N., Colmenarejo, S. G., Wang, Z., Belov, D., and de Freitas,\nN. (2017). Parallel multiscale autoregressive density estimation. arXiv preprint arXiv:1703.03664.\nRezende, D. and Mohamed, S. (2015). Variational inference with normalizing ﬂows. In Proceedings\nof The 32nd International Conference on Machine Learning, pages 1530–1538.\n9\nRussakovsky, O., Deng, J., Su, H., Krause, J., Satheesh, S., Ma, S., Huang, Z., Karpathy, A., Khosla,\nA., Bernstein, M., et al. (2015). Imagenet large scale visual recognition challenge. International\nJournal of Computer Vision, 115(3):211–252.\nSalimans, T. and Bulatov, Y . (2017). Gradient checkpointing. https://github.com/openai/\ngradient-checkpointing.\nSalimans, T. and Kingma, D. P. (2016). Weight normalization: A simple reparameterization to\naccelerate training of deep neural networks. arXiv preprint arXiv:1602.07868.\nVan Den Oord, A., Dieleman, S., Zen, H., Simonyan, K., Vinyals, O., Graves, A., Kalchbrenner,\nN., Senior, A., and Kavukcuoglu, K. (2016). Wavenet: A generative model for raw audio. arXiv\npreprint arXiv:1609.03499.\nvan den Oord, A., Kalchbrenner, N., and Kavukcuoglu, K. (2016a). Pixel recurrent neural networks.\narXiv preprint arXiv:1601.06759.\nvan den Oord, A., Kalchbrenner, N., Vinyals, O., Espeholt, L., Graves, A., and Kavukcuoglu, K.\n(2016b). Conditional image generation with PixelCNN decoders. arXiv preprint arXiv:1606.05328.\nYu, F., Zhang, Y ., Song, S., Seff, A., and Xiao, J. (2015). Lsun: Construction of a large-scale image\ndataset using deep learning with humans in the loop. arXiv preprint arXiv:1506.03365.\n10",
  "values": {
    "Respect for Law and public interest": "Yes",
    "Autonomy (power to decide)": "Yes",
    "Transparent (to users)": "Yes",
    "Interpretable (to users)": "Yes",
    "Non-maleficence": "Yes",
    "Respect for Persons": "Yes",
    "Privacy": "Yes",
    "Not socially biased": "Yes",
    "Beneficence": "Yes",
    "Explicability": "Yes",
    "Fairness": "Yes",
    "User influence": "Yes",
    "Collective influence": "Yes",
    "Critiqability": "Yes",
    "Justice": "Yes",
    "Deferral to humans": "Yes"
  }
}