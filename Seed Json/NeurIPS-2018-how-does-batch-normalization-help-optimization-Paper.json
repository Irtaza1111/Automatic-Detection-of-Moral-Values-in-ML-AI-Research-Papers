{
  "pdf": "NeurIPS-2018-how-does-batch-normalization-help-optimization-Paper",
  "title": "NeurIPS-2018-how-does-batch-normalization-help-optimization-Paper",
  "author": "Unknown",
  "paper_id": "NeurIPS-2018-how-does-batch-normalization-help-optimization-Paper",
  "text": "How Does Batch Normalization Help Optimization?\nShibani Santurkar∗\nMIT\nshibani@mit.edu\nDimitris Tsipras∗\nMIT\ntsipras@mit.edu\nAndrew Ilyas∗\nMIT\nailyas@mit.edu\nAleksander M ˛ adry\nMIT\nmadry@mit.edu\nAbstract\nBatch Normalization (BatchNorm) is a widely adopted technique that enables\nfaster and more stable training of deep neural networks (DNNs). Despite its\npervasiveness, the exact reasons for BatchNorm’s effectiveness are still poorly\nunderstood. The popular belief is that this effectiveness stems from controlling\nthe change of the layers’ input distributions during training to reduce the so-called\n“internal covariate shift”. In this work, we demonstrate that such distributional\nstability of layer inputs has little to do with the success of BatchNorm. Instead,\nwe uncover a more fundamental impact of BatchNorm on the training process: it\nmakes the optimization landscape signiﬁcantly smoother. This smoothness induces\na more predictive and stable behavior of the gradients, allowing for faster training.\n1 Introduction\nOver the last decade, deep learning has made impressive progress on a variety of notoriously\ndifﬁcult tasks in computer vision [ 16, 7], speech recognition [ 5], machine translation [ 29], and\ngame-playing [18, 25]. This progress hinged on a number of major advances in terms of hardware,\ndatasets [15, 23], and algorithmic and architectural techniques [ 27, 12, 20, 28]. One of the most\nprominent examples of such advances was batch normalization (BatchNorm) [10].\nAt a high level, BatchNorm is a technique that aims to improve the training of neural networks by\nstabilizing the distributions of layer inputs. This is achieved by introducing additional network layers\nthat control the ﬁrst two moments (mean and variance) of these distributions.\nThe practical success of BatchNorm is indisputable. By now, it is used by default in most deep learning\nmodels, both in research (more than 6,000 citations) and real-world settings. Somewhat shockingly,\nhowever, despite its prominence, we still have a poor understanding of what the effectiveness of\nBatchNorm is stemming from. In fact, there are now a number of works that provide alternatives to\nBatchNorm [1, 3, 13, 31], but none of them seem to bring us any closer to understanding this issue.\n(A similar point was also raised recently in [22].)\nCurrently, the most widely accepted explanation of BatchNorm’s success, as well as its original\nmotivation, relates to so-called internal covariate shift (ICS). Informally, ICS refers to the change in\nthe distribution of layer inputs caused by updates to the preceding layers. It is conjectured that such\ncontinual change negatively impacts training. The goal of BatchNorm was to reduce ICS and thus\nremedy this effect.\nEven though this explanation is widely accepted, we seem to have little concrete evidence supporting\nit. In particular, we still do not understand the link between ICS and training performance. The chief\ngoal of this paper is to address all these shortcomings. Our exploration lead to somewhat startling\ndiscoveries.\n∗Equal contribution.\n32nd Conference on Neural Information Processing Systems (NeurIPS 2018), Montréal, Canada.\nOur Contributions. Our point of start is demonstrating that there does not seem to be any link\nbetween the performance gain of BatchNorm and the reduction of internal covariate shift. Or that this\nlink is tenuous, at best. In fact, we ﬁnd that in a certain sense BatchNorm might not even be reducing\ninternal covariate shift.\nWe then turn our attention to identifying the roots of BatchNorm’s success. Speciﬁcally, we demon-\nstrate that BatchNorm impacts network training in a fundamental way: it makes the landscape of\nthe corresponding optimization problem signiﬁcantly more smooth. This ensures, in particular, that\nthe gradients are more predictive and thus allows for use of larger range of learning rates and faster\nnetwork convergence. We provide an empirical demonstration of these ﬁndings as well as their\ntheoretical justiﬁcation. We prove that, under natural conditions, the Lipschitzness of both the loss\nand the gradients (also known asβ-smoothness [21]) are improved in models with BatchNorm.\nFinally, we ﬁnd that this smoothening effect is not uniquely tied to BatchNorm. A number of other\nnatural normalization techniques have a similar (and, sometime, even stronger) effect. In particular,\nthey all offer similar improvements in the training performance.\nWe believe that understanding the roots of such a fundamental techniques as BatchNorm will let us\nhave a signiﬁcantly better grasp of the underlying complexities of neural network training and, in\nturn, will inform further algorithmic progress in this context.\nOur paper is organized as follows. In Section 2, we explore the connections between BatchNorm,\noptimization, and internal covariate shift. Then, in Section 3, we demonstrate and analyze the exact\nroots of BatchNorm’s success in deep neural network training. We present our theoretical analysis in\nSection 4. We discuss further related work in Section 5 and conclude in Section 6.\n2 Batch normalization and internal covariate shift\nBatch normalization (BatchNorm) [10] has been arguably one of the most successful architectural\ninnovations in deep learning. But even though its effectiveness is indisputable, we do not have a ﬁrm\nunderstanding of why this is the case.\nBroadly speaking, BatchNorm is a mechanism that aims to stabilize the distribution (over a mini-\nbatch) of inputs to a given network layer during training. This is achieved by augmenting the network\nwith additional layers that set the ﬁrst two moments (mean and variance) of the distribution of each\nactivation to be zero and one respectively. Then, the batch normalized inputs are also typically scaled\nand shifted based on trainable parameters to preserve model expressivity. This normalization is\napplied before the non-linearity of the previous layer.\nOne of the key motivations for the development of BatchNorm was the reduction of so-calledinternal\ncovariate shift (ICS). This reduction has been widely viewed as the root of BatchNorm’s success.\nIoffe and Szegedy [10] describe ICS as the phenomenon wherein the distribution of inputs to a layer\nin the network changes due to an update of parameters of the previous layers. This change leads to a\nconstant shift of the underlying training problem and is thus believed to have detrimental effect on\nthe training process.\n0 5k 10k 15k\nSteps\n50\n100\nTraining Accuracy (%)\nStandard, LR=0.1\nStandard + BatchNorm, LR=0.1\nStandard, LR=0.5\nStandard + BatchNorm, LR=0.5\n0 5k 10k 15k\nSteps\n50\n100\nTest Accuracy (%)\nStandard, LR=0.1\nStandard + BatchNorm, LR=0.1\nStandard, LR=0.5\nStandard + BatchNorm, LR=0.5\nLayer #3\nStandard \n (LR=0.1)\nStandard + BatchNorm \n (LR=0.1)\nLayer #11\nFigure 1: Comparison of (a) training (optimization) and (b) test (generalization) performance of a\nstandard VGG network trained on CIFAR-10 with and without BatchNorm (details in Appendix A).\nThere is a consistent gain in training speed in models with BatchNorm layers. (c) Even though the\ngap between the performance of the BatchNorm and non-BatchNorm networks is clear, the difference\nin the evolution of layer input distributions seems to be much less pronounced. (Here, we sampled\nactivations of a given layer and visualized their distribution over training steps.)\n2\nDespite its fundamental role and widespread use in deep learning, the underpinnings of BatchNorm’s\nsuccess remain poorly understood [22]. In this work we aim to address this gap. To this end, we start\nby investigating the connection between ICS and BatchNorm. Speciﬁcally, we consider ﬁrst training\na standard VGG [26] architecture on CIFAR-10 [15] with and without BatchNorm. As expected,\nFigures 1(a) and (b) show a drastic improvement, both in terms of optimization and generalization\nperformance, for networks trained with BatchNorm layers. Figure 1(c) presents, however, a surprising\nﬁnding. In this ﬁgure, we visualize to what extent BatchNorm is stabilizing distributions of layer\ninputs by plotting the distribution (over a batch) of a random input over training. Surprisingly, the\ndifference in distributional stability (change in the mean and variance) in networks with and without\nBatchNorm layers seems to be marginal. This observation raises the following questions:\n(1) Is the effectiveness of BatchNorm indeed related to internal covariate shift?\n(2) Is BatchNorm’s stabilization of layer input distributions even effective in reducing ICS?\nWe now explore these questions in more depth.\n2.1 Does BatchNorm’s performance stem from controlling internal covariate shift?\nThe central claim in [10] is that controlling the mean and variance of distributions of layer inputs is\ndirectly connected to improved training performance. Can we, however, substantiate this claim?\nWe propose the following experiment. We train networks withrandom noise injected after BatchNorm\nlayers. Speciﬁcally, we perturb each activation for each sample in the batch using i.i.d. noise sampled\nfrom a non-zero mean and non-unit variance distribution. We emphasize that this noise distribution\nchanges at each time step (see Appendix A for implementation details).\nNote that such noise injection produces a severe covariate shift that skews activations at every time\nstep. Consequently, every unit in the layer experiences a different distribution of inputs at each\ntime step. We then measure the effect of this deliberately introduced distributional instability on\nBatchNorm’s performance. Figure 2 visualizes the training behavior of standard, BatchNorm and our\n“noisy” BatchNorm networks. Distributions of activations over time from layers at the same depth in\neach one of the three networks are shown alongside.\nObserve that the performance difference between models with BatchNorm layers, and “noisy” Batch-\nNorm layers is almost non-existent. Also, both these networks perform much better than standard\nnetworks. Moreover, the “noisy” BatchNorm network has qualitatively less stable distributions than\neven the standard, non-BatchNorm network, yet it still performs better in terms of training. To put\n0 5k 10k 15k\nSteps\n0\n20\n40\n60\n80\n100\nTraining AccuracyStandard\nStandard + BatchNorm\nStandard + \"Noisy\" Batchnorm\nLayer #2\nStandard \nStandard + \n BatchNorm\nStandard + \n \"Noisy\" BatchNorm\nLayer #9\nLayer #13\nFigure 2: Connections between distributional stability and BatchNorm performance: We compare\nVGG networks trained without BatchNorm (Standard), with BatchNorm (Standard + BatchNorm)\nand with explicit “covariate shift” added to BatchNorm layers (Standard + “Noisy” BatchNorm).\nIn the later case, we induce distributional instability by adding time-varying, non-zero mean and\nnon-unit variance noise independently to each batch normalized activation. The “noisy” BatchNorm\nmodel nearly matches the performance of standard BatchNorm model, despite complete distributional\ninstability. We sampled activations of a given layer and visualized their distributions (also cf. Figure 7).\n3\n25\n50\n75\n100Training Accuracy (%)\nLR = 0.1LR = 0.1\nStandard\nStandard +  \n BatchNorm\n10 1\n2-diff.\nLayer #5\n0\n1\nCos Angle\nLayer #10\n(a) VGG\n103\n104\nTraining Loss\nLR = 1e-07LR = 1e-07\nStandard\nStandard + \n BatchNorm\n102\n2-Diff.\nLayer #9\n0\n1\nCos Angle\nLayer #17\n(b) DLN\nFigure 3: Measurement of ICS (as deﬁned in Deﬁnition 2.1) in networks with and without BatchNorm\nlayers. For a layer we measure the cosine angle (ideally 1) andℓ2-difference of the gradients (ideally\n0) before and after updates to the preceding layers (see Deﬁnition 2.1). Models with BatchNorm have\nsimilar, or even worse, internal covariate shift, despite performing better in terms of accuracy and\nloss. (Stabilization of BatchNorm faster during training is an artifact of parameter convergence.)\nthe magnitude of the noise into perspective, we plot the mean and variance of random activations\nfor select layers in Figure 7. Moreover, adding the same amount of noise to the activations of the\nstandard (non-BatchNorm) network prevents it from training entirely.\nClearly, these ﬁndings are hard to reconcile with the claim that the performance gain due to Batch-\nNorm stems from increased stability of layer input distributions.\n2.2 Is BatchNorm reducing internal covariate shift?\nOur ﬁndings in Section 2.1 make it apparent that ICS is not directly connected to the training\nperformance, at least if we tie ICS to stability of the mean and variance of input distributions. One\nmight wonder, however: Is there a broader notion of internal covariate shift that has such a direct link\nto training performance? And if so, does BatchNorm indeed reduce this notion?\nRecall that each layer can be seen as solving an empirical risk minimization problem where given a\nset of inputs, it is optimizing some loss function (that possibly involves later layers). An update to the\nparameters of any previous layer will change these inputs, thus changing this empirical risk mini-\nmization problem itself. This phenomenon is at the core of the intuition that Ioffe and Szegedy [10]\nprovide regarding internal covariate shift. Speciﬁcally, they try to capture this phenomenon from\nthe perspective of the resulting distributional changes in layer inputs. However, as demonstrated in\nSection 2.1, this perspective does not seem to properly encapsulate the roots of BatchNorm’s success.\nTo answer this question, we consider a broader notion of internal covariate shift that is more tied to\nthe underlying optimization task. (After all the success of BatchNorm is largely of an optimization\nnature.) Since the training procedure is a ﬁrst-order method, the gradient of the loss is the most natural\nobject to study. To quantify the extent to which the parameters in a layer would have to “adjust” in\nreaction to a parameter update in the previous layers, we measure the difference between the gradients\nof each layer before and after updates to all the previous layers. This leads to the following deﬁnition.\nDeﬁnition 2.1. Let L be the loss, W (t)\n1 , . . . ,W (t)\nk be the parameters of each of the k layers and\n(x(t),y (t)) be the batch of input-label pairs used to train the network at time t. We deﬁne internal\ncovariate shift (ICS) of activationi at timet to be the difference ||Gt,i −G′\nt,i||2, where\nGt,i = ∇W (t)\ni\nL(W (t)\n1 ,...,W (t)\nk ;x(t),y (t))\nG′\nt,i = ∇W (t)\ni\nL(W (t+1)\n1 ,...,W (t+1)\ni−1 ,W (t)\ni ,W (t)\ni+1,...,W (t)\nk ;x(t),y (t)).\nHere, Gt,i corresponds to the gradient of the layer parameters that would be applied during a\nsimultaneous update of all layers (as is typical). On the other hand, G′\nt,i is the same gradient after all\n4\n0 5k 10k 15k\nSteps\n100\n101\nLoss Landscape\nStandard\nStandard + BatchNorm\n(a) loss landscape\n0 5k 10k 15k\nSteps\n0\n50\n100\n150\n200\n250Gradient Predictiveness\nStandard\nStandard + BatchNorm (b) gradient predictiveness\n0 5k 10k 15k\nSteps\n5\n10\n15\n20\n25\n30\n35\n40\n45-smoothness\nStandard\nStandard + BatchNorm (c) “effective” β-smoothness\nFigure 4: Analysis of the optimization landscape of VGG networks. At a particular training step,\nwe measure the variation (shaded region) in loss (a) andℓ2 changes in the gradient (b) as we move\nin the gradient direction. The “effective” β-smoothness (c) refers to the maximum difference (in\nℓ2-norm) in gradient over distance moved in that direction. There is a clear improvement in all of\nthese measures in networks with BatchNorm, indicating a more well-behaved loss landscape. (Here,\nwe cap the maximum distance to beη = 0.4× the gradient since for larger steps the standard network\njust performs worse (see Figure 1). BatchNorm however continues to provide smoothing for even\nlarger distances.) Note that these results are supported by our theoretical ﬁndings (Section 4).\nthe previous layers have been updated with their new values. The difference betweenG andG′ thus\nreﬂects the change in the optimization landscape of Wi caused by the changes to its input. It thus\ncaptures precisely the effect of cross-layer dependencies that could be problematic for training.\nEquipped with this deﬁnition, we measure the extent of ICS with and without BatchNorm layers. To\nisolate the effect of non-linearities as well as gradient stochasticity, we also perform this analysis on\n(25-layer) deep linear networks (DLN) trained with full-batch gradient descent (see Appendix A for\ndetails). The conventional understanding of BatchNorm suggests that the addition of BatchNorm\nlayers in the network should increase the correlation betweenG andG′, thereby reducing ICS.\nSurprisingly, we observe that networks with BatchNorm often exhibit anincrease in ICS (cf. Figure 3).\nThis is particularly striking in the case of DLN. In fact, in this case, the standard network experiences\nalmost no ICS for the entirety of training, whereas for BatchNorm it appears that G andG′ are\nalmost uncorrelated. We emphasize that this is the case even though BatchNorm networks continue to\nperform drastically better in terms of attained accuracy and loss. (The stabilization of the BatchNorm\nVGG network later in training is an artifact of faster convergence.) This evidence suggests that, from\noptimization point of view BatchNorm might not even reduce the internal covariate shift.\n3 Why does BatchNorm work?\nOur investigation so far demonstrated that the generally asserted link between the internal covariate\nshift (ICS) and the optimization performance is tenuous, at best. But BatchNorm does signiﬁcantly\nimprove the training process. Can we explain why this is the case?\nAside from reducing ICS, Ioffe and Szegedy [ 10] identify a number of additional properties of\nBatchNorm. These include prevention of exploding or vanishing gradients, robustness to different\nsettings of hyperparameters such as learning rate and initialization scheme, and keeping most of the\nactivations away from saturation regions of non-linearities. All these properties are clearly beneﬁcial\nto the training process. But they are fairly simple consequences of the mechanics of BatchNorm\nand do little to uncover the underlying factors responsible for BatchNorm’s success. Is there a more\nfundamental phenomenon at play here?\n3.1 The smoothing effect of BatchNorm\nIndeed, we identify the key impact that BatchNorm has on the training process: it reparametrizes\nthe underlying optimization problem to make its landscape signiﬁcantly more smooth . The ﬁrst\nmanifestation of this impact is improvement in the Lipschitzness2 of the loss function. That is, the\nloss changes at a smaller rate and the magnitudes of the gradients are smaller too. There is, however,\n2Recall thatf isL-Lipschitz if|f (x1)−f (x2)|≤ L∥x1−x2∥, for allx1 andx2.\n5\nan even stronger effect at play. Namely, BatchNorm’s reparametrization makesgradients of the loss\nmore Lipschitz too. In other words, the loss exhibits a signiﬁcantly better “effective” β-smoothness3.\nThese smoothening effects impact the performance of the training algorithm in a major way. To\nunderstand why, recall that in a vanilla (non-BatchNorm), deep neural network, the loss function\nis not only non-convex but also tends to have a large number of “kinks”, ﬂat regions, and sharp\nminima [17]. This makes gradient descent–based training algorithms unstable, e.g., due to exploding\nor vanishing gradients, and thus highly sensitive to the choice of the learning rate and initialization.\nNow, the key implication of BatchNorm’s reparametrization is that it makes the gradients more\nreliable and predictive. After all, improved Lipschitzness of the gradients gives us conﬁdence that\nwhen we take a larger step in a direction of a computed gradient, this gradient direction remains a\nfairly accurate estimate of the actual gradient direction after taking that step. It thus enables any\n(gradient–based) training algorithm to take larger steps without the danger of running into a sudden\nchange of the loss landscape such as ﬂat region (corresponding to vanishing gradient) or sharp local\nminimum (causing exploding gradients). This, in turn, enables us to use a broader range of (and thus\nlarger) learning rates (see Figure 10 in Appendix B) and, in general, makes the training signiﬁcantly\nfaster and less sensitive to hyperparameter choices. (This also illustrates how the properties of\nBatchNorm that we discussed earlier can be viewed as a manifestation of this smoothening effect.)\n3.2 Exploration of the optimization landscape\nTo demonstrate the impact of BatchNorm on the stability of the loss itself, i.e., its Lipschitzness, for\neach given step in the training process, we compute the gradient of the loss at that step and measure\nhow the loss changes as we move in that direction – see Figure 4(a). We see that, in contrast to the\ncase when BatchNorm is in use, the loss of a vanilla, i.e., non-BatchNorm, network has a very wide\nrange of values along the direction of the gradient, especially in the initial phases of training. (In the\nlater stages, the network is already close to convergence.)\nSimilarly, to illustrate the increase in the stability and predictiveness of the gradients, we make\nanalogous measurements for theℓ2 distance between the loss gradient at a given point of the training\nand the gradients corresponding to different points along the original gradient direction. Figure 4(b)\nshows a signiﬁcant difference (close to two orders of magnitude) in such gradient predictiveness\nbetween the vanilla and BatchNorm networks, especially early in training.\nTo further demonstrate the effect of BatchNorm on the stability/Lipschitzness of the gradients of the\nloss, we plot in Figure 4(c) the “effective” β-smoothness of the vanilla and BatchNorm networks\nthroughout the training. (“Effective” refers here to measuring the change of gradients as we move in\nthe direction of the gradients.). Again, we observe consistent differences between these networks.\nWe complement the above examination by consideringlinear deep networks: as shown in Figures 9\nand 12 in Appendix B, the BatchNorm smoothening effect is present there as well.\nFinally, we emphasize that even though our explorations were focused on the behavior of the loss\nalong the gradient directions (as they are the crucial ones from the point of view of the training\nprocess), the loss behaves in a similar way when we examine other (random) directions too.\n3.3 Is BatchNorm the best (only?) way to smoothen the landscape?\nGiven this newly acquired understanding of BatchNorm and the roots of its effectiveness, it is natural\nto wonder: Is this smoothening effect a unique feature of BatchNorm? Or could a similar effect be\nachieved using some other normalization schemes?\nTo answer this question, we study a few natural data statistics-based normalization strategies. Speciﬁ-\ncally, we study schemes that ﬁx the ﬁrst order moment of the activations, as BatchNorm does, and then\nnormalizes them by the average of theirℓp-norm (before shifting the mean), forp = 1, 2, ∞. Note\nthat for these normalization schemes, the distributions of layer inputs are no longer Gaussian-like\n(see Figure 14). Hence, normalization with suchℓp-norm does not guarantee anymore any control\nover the distribution moments nor distributional stability.\n3Recall that f isβ-smooth if its gradient is β-Lipschitz. It is worth noting that, due to the existence of\nnon-linearities, one should not expect theβ-smoothness to be bounded in an absolute, global sense.\n6\nyt−μ\nσ\n̂y\nyx\nγ̂y+β\nz\nBatchNorm\nW L\n(a) Vanilla Network\nyt−μ\nσ\n̂yyx γ̂y+β\nz\nBatchNorm\nW b\nL (b) Vanilla Network + BatchNorm Layer\nFigure 5: The two network architectures we compare in our theoretical analysis: (a) the vanilla DNN\n(no BatchNorm layer); (b) the same network as in (a) but with a BatchNorm layer inserted after the\nfully-connected layerW . (All the layer parameters have exactly the same value in both networks.)\nThe results are presented in Figures 13, 11 and 12 in Appendix B. We observe that all the normalization\nstrategies offer comparable performance to BatchNorm. In fact, for deep linear networks, ℓ1–\nnormalization performs even better than BatchNorm. Note that, qualitatively, theℓp–normalization\ntechniques lead to larger distributional shift(as considered in [10]) than the vanilla, i.e., unnormalized,\nnetworks, yet they still yield improved optimization performance. Also, all these techniques result in\nan improved smoothness of the landscape that is similar to the effect of BatchNorm. (See Figures 11\nand 12 of Appendix B.) This suggests that the positive impact of BatchNorm on training might be\nsomewhat serendipitous. Therefore, it might be valuable to perform a principled exploration of the\ndesign space of normalization schemes as it can lead to better performance.\n4 Theoretical Analysis\nOur experiments so far suggest that BatchNorm has a fundamental effect on the optimization\nlandscape. We now explore this phenomenon from a theoretical perspective. To this end, we consider\nan arbitrary linear layer in a DNN (we do not necessitate that the entire network be fully linear).\n4.1 Setup\nWe analyze the impact of adding a single BatchNorm layer after an arbitrary fully-connected layerW\nat a given step during the training. Speciﬁcally, we compare the optimization landscape of the original\ntraining problem to the one that results from inserting the BatchNorm layer after the fully-connected\nlayer – normalizing the output of this layer (see Figure 5). Our analysis therefore captures effects that\nstem from the reparametrization of the landscape and not merely from normalizing the inputsx.\nWe denote the layer weights (identical for both the standard and batch-normalized networks) asWij.\nBoth networks have the same arbitrary loss function L that could potentially include a number of\nadditional non-linear layers after the current one. We refer to the loss of the normalized network as\nˆL for clarity. In both networks, we have inputx, and lety =Wx . For networks with BatchNorm,\nwe have an additional set of activations ˆy, which are the “whitened” version of y, i.e. standardized\nto mean 0 and variance 1. These are then multiplied byγ and added toβ to formz. We assumeβ\nandγ to be constants for our analysis. In terms of notation, we letσj denote the standard deviation\n(computed over the mini-batch) of a batch of outputsyj ∈ Rm.\n4.2 Theoretical Results\nWe begin by considering the optimization landscape with respect to the activationsyj. We show that\nbatch normalization causes this landscape to be more well-behaved, inducing favourable properties in\nLipschitz-continuity, and predictability of the gradients. We then show that these improvements in the\nactivation-space landscape translate to favorable worst-case bounds in the weight-space landscape.\nWe ﬁrst turn our attention to the gradient magnitude\n⏐⏐⏐⏐∇yj L\n⏐⏐⏐⏐, which captures the Lipschitzness\nof the loss. The Lipschitz constant of the loss plays a crucial role in optimization, since it controls\nthe amount by which the loss can change when taking a step (see [ 21] for details). Without any\nassumptions on the speciﬁc weights or the loss being used, we show that the batch-normalized\n7\nlandscape exhibits a better Lipschitz constant. Moreover, the Lipschitz constant is signiﬁcantly\nreduced whenever the activations ˆyj correlate with the gradient ∇ ˆyj\nˆL or the mean of the gradient\ndeviates from 0. Note that this reduction is additive, and has effect even when the scaling of BN is\nidentical to the original layer scaling (i.e. even whenσj =γ).\nTheorem 4.1 (The effect of BatchNorm on the Lipschitzness of the loss). For a BatchNorm network\nwith loss ˆL and an identical non-BN network with (identical) loss L,\n⏐⏐⏐\n⏐⏐⏐∇yj\nˆL\n⏐⏐⏐\n⏐⏐⏐\n2\n≤ γ2\nσ2\nj\n(⏐⏐⏐⏐∇yj L\n⏐⏐⏐⏐2\n− 1\nm\n⟨\n1, ∇yj L\n⟩2\n− 1√m\n⟨\n∇yj L, ˆyj\n⟩2\n)\n.\nFirst, note that ⟨1,∂L/∂y ⟩2 grows quadratically in the dimension, so the middle term above is\nsigniﬁcant. Furthermore, the ﬁnal inner product term is expected to be bounded away from zero, as\nthe gradient with respect to a variable is rarely uncorrelated to the variable itself. In addition to the\nadditive reduction,σj tends to be large in practice (cf. Appendix Figure 8), and thus the scaling by γ\nσ\nmay contribute to the relative “ﬂatness\" we see in the effective Lipschitz constant.\nWe now turn our attention to the second-order properties of the landscape. We show that when a\nBatchNorm layer is added, the quadratic form of the loss Hessian with respect to the activations in the\ngradient direction, is both rescaled by the input variance (inducing resilience to mini-batch variance),\nand decreased by an additive factor (increasing smoothness). This term captures the second order\nterm of the Taylor expansion of the gradient around the current point. Therefore, reducing this term\nimplies that the ﬁrst order term (the gradient) is more predictive.\nTheorem 4.2 (The effect of BN to smoothness). Let ˆgj = ∇yj L andHjj = ∂L\n∂yj∂yj\nbe the gradient\nand Hessian of the loss with respect to the layer outputs respectively. Then\n(\n∇yj\nˆL\n)⊤ ∂ ˆL\n∂yj∂yj\n(\n∇yj\nˆL\n)\n≤ γ2\nσ2\n(\n∂ ˆL\n∂yj\n)⊤\nHjj\n(\n∂ ˆL\n∂yj\n)\n− γ\nmσ2⟨ˆgj, ˆyj⟩\n⏐⏐⏐⏐⏐\n⏐⏐⏐⏐⏐\n∂ ˆL\n∂yj\n⏐⏐⏐⏐⏐\n⏐⏐⏐⏐⏐\n2\nIf we also have that theHjj preserves the relative norms of ˆgj and ∇yj\nˆL,\n(\n∇yj\nˆL\n)⊤ ∂ ˆL\n∂yj∂yj\n(\n∇yj\nˆL\n)\n≤ γ2\nσ2\n(\nˆg⊤\nj Hjj ˆgj− 1\nmγ⟨ˆgj, ˆyj⟩\n⏐⏐⏐⏐⏐\n⏐⏐⏐⏐⏐\n∂ ˆL\n∂yj\n⏐⏐⏐⏐⏐\n⏐⏐⏐⏐⏐\n2)\nNote that if the quadratic forms involving the Hessian and the inner product⟨ˆyj, ˆgj⟩ are non-negative\n(both fairly mild assumptions), the theorem implies more predictive gradients. The Hessian is positive\nsemi-deﬁnite (PSD) if the loss is locally convex which is true for the case of deep networks with\npiecewise-linear activation functions and a convex loss at the ﬁnal layer (e.g. standard softmax\ncross-entropy loss or other common losses). The condition ⟨ˆyj, ˆgj⟩> 0 holds as long as the negative\ngradient ˆgj is pointing towards the minimum of the loss (w.r.t. normalized activations). Overall, as\nlong as these two conditions hold, the steps taken by the BatchNorm network are more predictive\nthan those of the standard network (similarly to what we observed experimentally).\nNote that our results stem from the reparametrization of the problem and not a simple scaling.\nObservation 4.3 (BatchNorm does more than rescaling). For any input dataX and network conﬁgu-\nrationW , there exists a BN conﬁguration (W,γ,β ) that results in the same activationsyj, and where\nγ =σj. Consequently, all of the minima of the normal landscape are preserved in the BN landscape.\nOur theoretical analysis so far studied the optimization landscape of the loss w.r.t. the normalized\nactivations. We will now translate these bounds to a favorable worst-case bound on the landscape\nwith respect to layer weights. Note that a (near exact) analogue of this theorem for minimax gradient\npredictiveness appears in Theorem C.1 of Appendix C.\nTheorem 4.4 (Minimax bound on weight-space Lipschitzness). For a BatchNorm network with loss\nˆL and an identical non-BN network (with identical loss L), if\ngj = max\n||X||≤λ\n||∇WL||2, ˆgj = max\n||X||≤λ\n⏐⏐⏐\n⏐⏐⏐∇W ˆL\n⏐⏐⏐\n⏐⏐⏐\n2\n=⇒ ˆgj≤ γ2\nσ2\nj\n(\ng2\nj−mµ2\ngj−λ2 ⟨\n∇yjL, ˆyj\n⟩2)\n.\nFinally, in addition to a desirable landscape, we ﬁnd that BN also offers an advantage in initialization:\n8\nLemma 4.5 (BatchNorm leads to a favourable initialization). LetW∗ and ˆW∗ be the set of local\noptima for the weights in the normal and BN networks, respectively. For any initializationW0\n⏐⏐⏐\n⏐⏐⏐W0 − ˆW∗\n⏐⏐⏐\n⏐⏐⏐\n2\n≤ ||W0 −W∗||2 − 1\n||W∗||2\n(\n||W∗||2 − ⟨W∗,W 0⟩\n)2\n,\nif ⟨W0,W∗⟩> 0, where ˆW∗ andW∗ are closest optima for BN and standard network, respectively.\n5 Related work\nA number of normalization schemes have been proposed as alternatives to BatchNorm, including\nnormalization over layers [1], subsets of the batch [31], or across image dimensions [30]. Weight\nNormalization [ 24] follows a complementary approach normalizing the weights instead of the\nactivations. Finally, ELU [3] and SELU [13] are two proposed examples of non-linearities that have\na progressively decaying slope instead of a sharp saturation and can be used as an alternative for\nBatchNorm. These techniques offer an improvement over standard training that is comparable to that\nof BatchNorm but do not attempt to explain BatchNorm’s success.\nAdditionally, work on topics related to DNN optimization has uncovered a number of other Batch-\nNorm beneﬁts. Li et al. [ 9] observe that networks with BatchNorm tend to have optimization\ntrajectories that rely less on the parameter initialization. Balduzzi et al. [ 2] observe that models\nwithout BatchNorm tend to suffer from small correlation between different gradient coordinates\nand/or unit activations. They report that this behavior is profound in deeper models and argue how it\nconstitutes an obstacle to DNN optimization. Morcos et al. [19] focus on the generalization properties\nof DNN. They observe that the use of BatchNorm results in models that rely less on single directions\nin the activation space, which they ﬁnd to be connected to the generalization properties of the model.\nRecent work [14] identiﬁes simple, concrete settings where a variant of training with BatchNorm\nprovably improves over standard training algorithms. The main idea is that decoupling the length and\ndirection of the weights (as done in BatchNorm and Weight Normalization [24]) can be exploited to\na large extent. By designing algorithms that optimize these parameters separately, with (different)\nadaptive step sizes, one can achieve signiﬁcantly faster convergence rates for these problems.\n6 Conclusions\nIn this work, we have investigated the roots of BatchNorm’s effectiveness as a technique for training\ndeep neural networks. We ﬁnd that the widely believed connection between the performance of\nBatchNorm and the internal covariate shift is tenuous, at best. In particular, we demonstrate that\nexistence of internal covariate shift, at least when viewed from the – generally adopted – distributional\nstability perspective, is not a good predictor of training performance. Also, we show that, from an\noptimization viewpoint, BatchNorm might not be even reducing that shift.\nInstead, we identify a key effect that BatchNorm has on the training process: it reparametrizes the\nunderlying optimization problem to make it more stable (in the sense of loss Lipschitzness) and\nsmooth (in the sense of “effective” β-smoothness of the loss). This implies that the gradients used in\ntraining are more predictive and well-behaved, which enables faster and more effective optimization.\nThis phenomena also explains and subsumes some of the other previously observed beneﬁts of\nBatchNorm, such as robustness to hyperparameter setting and avoiding gradient explosion/vanishing.\nWe also show that this smoothing effect is not unique to BatchNorm. In fact, several other natural\nnormalization strategies have similar impact and result in a comparable performance gain.\nWe believe that these ﬁndings not only challenge the conventional wisdom about BatchNorm but\nalso bring us closer to a better understanding of this technique. We also view these results as an\nopportunity to encourage the community to pursue a more systematic investigation of the algorithmic\ntoolkit of deep learning and the underpinnings of its effectiveness.\nFinally, our focus here was on the impact of BatchNorm on training but our ﬁndings might also shed\nsome light on the BatchNorm’s tendency to improve generalization. Speciﬁcally, it could be the case\nthat the smoothening effect of BatchNorm’s reparametrization encourages the training process to\nconverge to more ﬂat minima. Such minima are believed to facilitate better generalization [ 8, 11].\nWe hope that future work will investigate this intriguing possibility.\n9\nAcknowledgements\nWe thank Ali Rahimi and Ben Recht for helpful comments on a preliminary version of this paper.\nShibani Santurkar was supported by the National Science Foundation (NSF) under grants IIS-1447786,\nIIS-1607189, and CCF-1563880, and the Intel Corporation. Dimitris Tsipras was supported in part by\nthe NSF grant CCF-1553428 and the NSF Frontier grant CNS-1413920. Andrew Ilyas was supported\nin part by NSF awards CCF-1617730 and IIS-1741137, a Simons Investigator Award, a Google\nFaculty Research Award, and an MIT-IBM Watson AI Lab research grant. Aleksander M ˛ adry was\nsupported in part by an Alfred P. Sloan Research Fellowship, a Google Research Award, and the NSF\ngrants CCF-1553428 and CNS-1815221.\nReferences\n[1] Jimmy Lei Ba, Jamie Ryan Kiros, and Geoffrey E Hinton. Layer normalization. arXiv preprint\narXiv:1607.06450, 2016.\n[2] David Balduzzi, Marcus Frean, Lennox Leary, JP Lewis, Kurt Wan-Duo Ma, and Brian McWilliams.\nThe shattered gradients problem: If resnets are the answer, then what is the question? arXiv preprint\narXiv:1702.08591, 2017.\n[3] Djork-Arné Clevert, Thomas Unterthiner, and Sepp Hochreiter. Fast and accurate deep network learning\nby exponential linear units (elus). arXiv preprint arXiv:1511.07289, 2015.\n[4] Xavier Glorot and Yoshua Bengio. Understanding the difﬁculty of training deep feedforward neural\nnetworks. In Proceedings of the thirteenth international conference on artiﬁcial intelligence and statistics,\npages 249–256, 2010.\n[5] Alex Graves, Abdel-rahman Mohamed, and Geoffrey Hinton. Speech recognition with deep recurrent\nneural networks. In Acoustics, speech and signal processing (icassp), 2013 ieee international conference\non, pages 6645–6649. IEEE, 2013.\n[6] Moritz Hardt and Tengyu Ma. Identity matters in deep learning. arXiv preprint arXiv:1611.04231, 2016.\n[7] Kaiming He, Xiangyu Zhang, Shaoqing Ren, and Jian Sun. Deep residual learning for image recognition.\nIn Proceedings of the IEEE Conference on Computer Vision and Pattern Recognition, 2016.\n[8] Sepp Hochreiter and Jürgen Schmidhuber. Flat minima. Neural Computation, 9(1):1–42, 1997.\n[9] Daniel Jiwoong Im, Michael Tao, and Kristin Branson. An empirical analysis of deep network loss surfaces.\narXiv preprint arXiv:1612.04010, 2016.\n[10] Sergey Ioffe and Christian Szegedy. Batch normalization: Accelerating deep network training by reducing\ninternal covariate shift. arXiv preprint arXiv:1502.03167, 2015.\n[11] Nitish Shirish Keskar, Dheevatsa Mudigere, Jorge Nocedal, Mikhail Smelyanskiy, and Ping Tak Peter\nTang. On large-batch training for deep learning: Generalization gap and sharp minima. arXiv preprint\narXiv:1609.04836, 2016.\n[12] Diederik P Kingma and Jimmy Ba. Adam: A method for stochastic optimization. arXiv preprint\narXiv:1412.6980, 2014.\n[13] Günter Klambauer, Thomas Unterthiner, Andreas Mayr, and Sepp Hochreiter. Self-normalizing neural\nnetworks. In Advances in Neural Information Processing Systems, pages 972–981, 2017.\n[14] Jonas Kohler, Hadi Daneshmand, Aurelien Lucchi, Ming Zhou, Klaus Neymeyr, and Thomas Hofmann.\nTowards a theoretical understanding of batch normalization. arXiv preprint arXiv:1805.10694, 2018.\n[15] Alex Krizhevsky and Geoffrey Hinton. Learning multiple layers of features from tiny images. 2009.\n[16] Alex Krizhevsky, Ilya Sutskever, and Geoffrey E Hinton. Imagenet classiﬁcation with deep convolutional\nneural networks. In Advances in neural information processing systems, pages 1097–1105, 2012.\n[17] Hao Li, Zheng Xu, Gavin Taylor, and Tom Goldstein. Visualizing the loss landscape of neural nets. arXiv\npreprint arXiv:1712.09913, 2017.\n[18] V olodymyr Mnih, Koray Kavukcuoglu, David Silver, Andrei A Rusu, Joel Veness, Marc G Bellemare,\nAlex Graves, Martin Riedmiller, Andreas K Fidjeland, Georg Ostrovski, et al. Human-level control through\ndeep reinforcement learning. Nature, 518(7540):529, 2015.\n[19] Ari S Morcos, David GT Barrett, Neil C Rabinowitz, and Matthew Botvinick. On the importance of single\ndirections for generalization. arXiv preprint arXiv:1803.06959, 2018.\n[20] Vinod Nair and Geoffrey E Hinton. Rectiﬁed linear units improve restricted boltzmann machines. In\nProceedings of the 27th international conference on machine learning (ICML-10), 2010.\n10\n[21] Yurii Nesterov. Introductory lectures on convex optimization: A basic course, volume 87. Springer Science\n& Business Media, 2013.\n[22] Ali Rahimi and Ben Recht. Back when we were kids. In NIPS Test-of-Time Award Talk, 2017.\n[23] Olga Russakovsky, Jia Deng, Hao Su, Jonathan Krause, Sanjeev Satheesh, Sean Ma, Zhiheng Huang,\nAndrej Karpathy, Aditya Khosla, Michael Bernstein, Alexander C. Berg, and Li Fei-Fei. ImageNet Large\nScale Visual Recognition Challenge. International Journal of Computer Vision (IJCV), 115(3), 2015.\n[24] Tim Salimans and Diederik P Kingma. Weight normalization: A simple reparameterization to accelerate\ntraining of deep neural networks. In Advances in Neural Information Processing Systems, 2016.\n[25] David Silver, Aja Huang, Chris J Maddison, Arthur Guez, Laurent Sifre, George Van Den Driessche, Julian\nSchrittwieser, Ioannis Antonoglou, Veda Panneershelvam, Marc Lanctot, et al. Mastering the game of go\nwith deep neural networks and tree search. nature, 529(7587):484–489, 2016.\n[26] Karen Simonyan and Andrew Zisserman. Very deep convolutional networks for large-scale image recogni-\ntion. arXiv preprint arXiv:1409.1556, 2014.\n[27] Nitish Srivastava, Geoffrey Hinton, Alex Krizhevsky, Ilya Sutskever, and Ruslan Salakhutdinov. Dropout:\nA simple way to prevent neural networks from overﬁtting.The Journal of Machine Learning Research,\n15(1), 2014.\n[28] Ilya Sutskever, James Martens, George Dahl, and Geoffrey Hinton. On the importance of initialization and\nmomentum in deep learning. In International conference on machine learning, 2013.\n[29] Ilya Sutskever, Oriol Vinyals, and Quoc V Le. Sequence to sequence learning with neural networks. In\nAdvances in neural information processing systems, pages 3104–3112, 2014.\n[30] Dmitry Ulyanov, Andrea Vedaldi, and Victor Lempitsky. Instance normalization: The missing ingredient\nfor fast stylization. arXiv preprint arXiv:1607.08022, 2016.\n[31] Yuxin Wu and Kaiming He. Group normalization. arXiv preprint arXiv:1803.08494, 2018.\n11",
  "values": {
    "Interpretable (to users)": "No",
    "Deferral to humans": "No",
    "User influence": "No",
    "Critiqability": "No",
    "Explicability": "No",
    "Collective influence": "No",
    "Transparent (to users)": "No",
    "Respect for Persons": "No",
    "Beneficence": "No",
    "Not socially biased": "No",
    "Privacy": "No",
    "Fairness": "No",
    "Justice": "No",
    "Non-maleficence": "No",
    "Autonomy (power to decide)": "No",
    "Respect for Law and public interest": "No"
  }
}